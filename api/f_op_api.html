
---
layout: default
---
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
    <head>
        <title>PNNL: Global Arrays Toolkit Fortran API</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
        <meta  name="description" content="The Global Arrays (GA) toolkit
        provides an efficient and portable &quot;shared-memory&quot;
        programming interface for distributed-memory computers." />
        <meta name="keywords" content="PNNL, Global Arrays, EMSL" />
        <!--#include virtual="/docs/globalshared/globals.inc"-->
        <style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */</style>
<style type="text/css">
table {
    border-collapse:collapse;
}
table,th,td {
    /*border:1px solid gray;*/
    padding-left:10px;
    padding-right:10px;
    font-size:small;
}
</style>

    </head>
    <body>
<h3 id="ABS_VALUE">ABS VALUE</h3>
<i>Converts a global array to contain absolute values of its elements</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_abs_value</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Take the element-wise absolute value of the array. </p>
<hr/>
<h3 id="ABS_VALUE_PATCH">ABS VALUE PATCH</h3>
<i>Converts a patch of a global array to have absolute values of its elements</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_abs_value_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim), hi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Take the element-wise absolute value of the patch. </p>
<h4>See Also:</h4>
<a target="api" href="#ABS_VALUE">ABS VALUE</a>
<hr/>
<h3 id="ACC">ACC</h3>
<i>Accumulates data into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>buf</td><td>local buffer containing data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha</td><td>scale argument for accumulate</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer containing data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>alpha</td><td>scale argument for accumulate</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Combines data from local array buffer with data in the global array section. The local array is assumed to be have the same number of dimensions as the global array. </p>
<p>
 global array section (lo[],hi[]) += *alpha * buffer </p>
<p>
 </p>
<hr/>
<h3 id="ACCESS">ACCESS</h3>
<i>Accesses data locally allocated for a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_access</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim),hi(ndim)</td><td>patch specification</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>reference to local data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array of leading dimensions</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Provides access to the specified patch of array. Returns leading dimension ld and and MA-like index for the data. This routine is intended for writing new GA operations. A call to ga_access should normally follow a call to ga_distribution that returns coordinates of the patch associated with a processor. You need to make sure that the coordinates of the patch are valid (test values returned from ga_distribution). </p>
<p>
 Your code should include a MA include file, mafdecls.h. </p>
<pre>
          dbl_mb(index)  - for double precision data
          int_mb(index)  - for integer data
          dcpl_mb(index) - for double complex data
</pre>
<p>
</p>
<p>
 The addressing convention refers the first element of the patch. However, you can only pass that reference to another subroutine where it could be used like a normal array, see the following example. </p>
<p>
 Example </p>
<p>
 For a given subroutine: </p>
<pre>
          subroutine foo(A,  nrows, ncols lda)
          double precision A(lda,*)
          integer nrows, ncols
             ....
          end
</pre>
<p>
you can reference A(ilo:ihi,jlo:jhi) in the following way: </p>
<p>
 </p>
<pre>
          call foo(dbl_mb(index), ihi-ilo+1, jhi-jlo+1, lda)
</pre>
<p>
</p>
<p>
 Note that the size of the integer index must match the platform, 32-bit platforms need to use 4-byte integers and 64-bit platforms need to use 8-byte integers, regardless of whether the other integers in the program are compiled as 4 or 8-byte integers. This can create portability problems when code is being built on different platforms. Users can use the preprocessors symbol GA_ACCESS_INDEX_TYPE to correctly size the integers used as indices across different architectures. The GA_ACCESS_INDEX_TYPE is used instead of an integer declaration and the the global.fh file needs to be included in the subroutine. This will result in code that works for both 32 and 64-bit platforms without having to explicity convert the integer size. </p>
<p>
 </p>
<hr/>
<h3 id="ACCESS_BLOCK">ACCESS BLOCK</h3>
<i>Accesses a block in a block-cyclic distributed global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access_block</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>idx</td><td>block index</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>reference to local data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array of leading dimensions</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
This function can be used to gain direct access to the data represented by a single block in a global array with a block-cyclic data distribution.  The index idx is the index of the block in the array assuming that blocks are numbered sequentially in a column-major order. A quick way of determining whether a block with index idx is held locally on a processor is to calculate whether mod(idx,nproc) equals the processor ID, where nproc is the total number of processors. Once the index has been returned, local data can be accessed as described in the documentation for nga_access. Each call to nga_access_block should be followed by a call to either nga_release_block or nga_release_update_block. </p>
<p>
 Please check the documentation for the nga_access function for more information on how to use the index returned by this subroutine to access locally held data. </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>, <a target="api" href="#RELEASE_BLOCK">RELEASE BLOCK</a>, <a target="api" href="#RELEASE_UPDATE_BLOCK">RELEASE UPDATE BLOCK</a>
<hr/>
<h3 id="ACCESS_BLOCK_GRID">ACCESS BLOCK GRID</h3>
<i>Accesses data block in a block-cyclic distributed global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access_block_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>subscript of block in array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>reference to local data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array of leading dimensions</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
This function can be used to gain direct access to the data represented by a single block in a global array with a SCALAPACK block-cyclic data distribution that is based on an underlying processor grid. The subscript array contains the subscript of the block in the array of blocks. This subscript is based on the location of the block in a grid, each of whose dimensions is equal to the number of blocks that fit along that dimension. Once the index has been returned, local data can be accessed as described in the documentation for nga_access. Each call to nga_access_block_grid should be followed by a call to either nga_release_block_grid or nga_release_update_block_grid. </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>, <a target="api" href="#RELEASE_BLOCK_GRID">RELEASE BLOCK GRID</a>, <a target="api" href="#RELEASE_UPDATE_BLOCK_GRID">RELEASE UPDATE BLOCK GRID</a>
<hr/>
<h3 id="ACCESS_BLOCK_SEGMENT">ACCESS BLOCK SEGMENT</h3>
<i>Accesses local data for a specific global array block</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access_block_segment</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>proc</td><td>processor ID</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>reference to local data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>len</td><td>length of data on processor</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
This function can be used to gain access to the all the locally held data on a particular processor that is associated with a block-cyclic distributed array. Once the index has been returned, local data can be accessed as described in the documentation for nga_access. The parameter len is the number of data elements that are held locally. The data inside this segment has a lot of additional structure so this function is not generally useful to developers. It is primarily used inside the GA library to implement other GA routines. Each call to nga_access_block_segment should be followed by a call to either nga_release_block_segment or nga_release_update_block_segment. </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>, <a target="api" href="#RELEASE_BLOCK_SEGMENT">RELEASE BLOCK SEGMENT</a>, <a target="api" href="#RELEASE_UPDATE_BLOCK_SEGMENT">RELEASE UPDATE BLOCK SEGMENT</a>
<hr/>
<h3 id="ACCESS_GHOST_ELEMENT">ACCESS GHOST ELEMENT</h3>
<i>Accesses a specific ghost element locally allocated on a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access_ghost_element</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">subscript</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>index pointing to location of element indexed by subscript()</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>array of integers that index desired element</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array of strides for local data patch. These include ghost cell widths.</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This function can be used to return a pointer to any data element in the locally held portion of the global array and can be used to directly access ghost cell data. The array subscript refers to the local index of the element relative to the origin of the local patch (which is assumed to be indexed by (0,0,...)). </p>
<p>
 </p>
<p>
To use the index returned by the nga_access_ghost_element subroutine, see the documentation on nga_access. </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>, <a target="api" href="#RELEASE_GHOST_ELEMENT">RELEASE GHOST ELEMENT</a>, <a target="api" href="#RELEASE_UPDATE_GHOST_ELEMENT">RELEASE UPDATE GHOST ELEMENT</a>
<hr/>
<h3 id="ACCESS_GHOSTS">ACCESS GHOSTS</h3>
<i>Accesses the ghost cells allocated locally on a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_access_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions of local patch, including ghost cells</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>index</td><td>returns an index corresponding to the origin the global array patch held locally on the processor</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim)</td><td>physical dimenstions of the local array patch, including ghost cells</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
Provides access to the local patch of the global array. Returns leading dimension ld and and pointer for the data.  This routine will provide access to the ghost cell data residing on each processor. Calls to nga_access_ghosts should normally follow a call to nga_distribution that returns coordinates of the visible data patch associated with a processor. You need to make sure that the coordinates of the patch are valid (test values returned from nga_distribution). </p>
<p>
 You can only access local data. To see how to use the index returned by this subroutine, check the documentation on nga_acces. </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>, <a target="api" href="#RELEASE_GHOSTS">RELEASE GHOSTS</a>, <a target="api" href="#RELEASE_UPDATE_GHOSTS">RELEASE UPDATE GHOSTS</a>
<hr/>
<h3 id="ADD">ADD</h3>
<i>Adds corresponding values in two global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_add</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>alpha,beta</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 The arrays (which must be the same shape and identically aligned) are added together element-wise. </p>
<p>
 </p>
<pre>
        c = alpha * a  +  beta * b;
</pre>
<p>
</p>
<p>
 The result (c) may replace one of the input arrays (a/b). </p>
<p>
 </p>
<hr/>
<h3 id="ADD_CONSTANT">ADD CONSTANT</h3>
<i>Adds a constant to all elements in a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_add_constant</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span>  <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double/complex/integer/float</td><td>alpha</td><td>added value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Add the constant pointed by alpha to each element of the array. </p>
<hr/>
<h3 id="ADD_CONSTANT_PATCH">ADD CONSTANT PATCH</h3>
<i>Adds a constant to all elements in a global array patch</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_add_constant_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim), hi(ndim)</td><td>patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double/complex/integer/float</td><td>alpha</td><td>added value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Add the constant pointed by alpha to each element of the patch. </p>
<h4>See Also:</h4>
<a target="api" href="#ADD_CONSTANT">ADD CONSTANT</a>
<hr/>
<h3 id="ADD_DIAGONAL">ADD DIAGONAL</h3>
<i>Adds to the diagonal elements of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_add_diagonal</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_v</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Adds the elements of the vector g_v to the diagonal of this matrix g_a. </p>
<hr/>
<h3 id="ADD_PATCH">ADD PATCH</h3>
<i>Adds patches of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_add_patch</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span>
                        <span class="n">beta</span><span class="p">,</span>  <span class="n">g_b</span><span class="p">,</span> <span class="n">bilo</span><span class="p">,</span> <span class="n">bihi</span><span class="p">,</span> <span class="n">bjlo</span><span class="p">,</span> <span class="n">bjhi</span><span class="p">,</span>
                               <span class="n">g_c</span><span class="p">,</span> <span class="n">cilo</span><span class="p">,</span> <span class="n">cihi</span><span class="p">,</span> <span class="n">cjlo</span><span class="p">,</span> <span class="n">cjhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b, g_c</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>alpha, beta</td><td>scale factors patches</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ailo, aihi, ajlo, ajhi</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>bilo, bihi, bjlo, bjhi</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>cilo, cihi, cjlo, cjhi</td><td>g_c patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_add_patch</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span>
                         <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b, g_c</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>alpha,beta</td><td>scale factors for patches</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim), chi(ndim)</td><td>g_c patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Patches of arrays (which must have the same number of elements) are added together element-wise. </p>
<pre>
         c[ ][ ] = alpha * a[ ][ ] + beta * b[ ][ ]
</pre>
<p>
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ADD">ADD</a>
<hr/>
<h3 id="ALLOC_GATSCAT_BUF">ALLOC GATSCAT BUF</h3>
<i>Allocates an internal buffer for gather/scatter operations</i>
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">nga_alloc_gatscat_buf</span><span class="p">(</span><span class="n">nelems</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>nelems</td><td>maximum number of elements to scatter/gather</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
This function can be used to enhance the performance when the gather/scatter operations are being called multiple times in succession. If the maximum number of elements being called in any gather/scatter operation is known prior to executing a code segment, then some internal buffers used in the gather/scatter operations can be allocated beforehand instead of at every individual call. This can result in substantial performance boosts in some cases. When the buffers are no longer needed they can be removed using the corresponding free call. </p>
<h4>See Also:</h4>
<a target="api" href="#FREE_GATSCAT_BUF">FREE GATSCAT BUF</a>
<hr/>
<h3 id="ALLOCATE">ALLOCATE</h3>
<i>Allocates the array specified by a GA handle</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_allocate</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if allocation of g_a was successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function allocates the memory for the global array handle originally obtained using the GA_Create_handle function. At a minimum, the GA_Set_data function must be called before the memory is allocated. Other GA_Set_xxx functions can also be called before invoking this function. </p>
<p>
 Returns True if allocation of g_a was successful. </p>
<p>
 </p>
<hr/>
<h3 id="BRDCST">BRDCST</h3>
<i>Broadcasts elements among all processes</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_brdcst</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">lenbuf</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>type</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>byte</td><td>buf(lenbuf)</td><td>buffer contain broadcasted/received data</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>lenbuf</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>root</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the world processor group.</p>
<p>
Broadcast from process root to all other processes a message of length lenbuf. </p>
<p>
 This is operation is provided only for convenience purposes: it is available regardless of the message-passing library that GA is running. </p>
<hr/>
<h3 id="CHECK_HANDLE">CHECK HANDLE</h3>
<i>Checks whether a GA handle is valid</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_check_handle</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character(*)*</td><td>string</td><td>message string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Check that the global array handle g_a is valid ... if not, call ga_error with the string provided and some more info. </p>
<p>
 </p>
<hr/>
<h3 id="CLUSTER_NNODES">CLUSTER NNODES</h3>
<i>Returns total number of cluster (shared memory) nodes</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_cluster_nnodes</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 This functions returns the total number of nodes that the program is running on. On SMP architectures, this will be less than or equal to the total number of processors. </p>
<p>
 </p>
<hr/>
<h3 id="CLUSTER_NODEID">CLUSTER NODEID</h3>
<i>Returns cluster node Rank of the invoking process</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_cluster_nodeid</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 This function returns the node ID of the process. On SMP architectures with more than one processor per node, several processes may return the same node id. </p>
<p>
 </p>
<hr/>
<h3 id="CLUSTER_NPROCS">CLUSTER NPROCS</h3>
<i>Returns number of processes in a given cluster node</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_cluster_nprocs</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>inode</td><td>node id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This function returns the number of processors available on node inode. </p>
<p>
 </p>
<hr/>
<h3 id="CLUSTER_PROC_NODEID">CLUSTER PROC NODEID</h3>
<i>Returns cluster node rank of a specified process</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_cluster_proc_nodeid</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>proc</td><td>process id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This function returns the node ID of the specified process proc.  On SMP architectures with more than one processor per node, several processes may return the same node id. </p>
<p>
 </p>
<hr/>
<h3 id="CLUSTER_PROCID">CLUSTER PROCID</h3>
<i>Returns rank of a process from a cluster node rank and intra-node rank</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_cluster_procid</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">iproc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>inode</td><td>node id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>iproc</td><td>processor id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This function returns the processor id associated with node inode and the local processor ID iproc. If node inode has N processors, then the value of iproc lies between 0 and N-1. </p>
<p>
 </p>
<hr/>
<h3 id="COMPARE_DISTR">COMPARE DISTR</h3>
<i>Compares distributions of two global arrays</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_compare_distr</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if distributions are identical</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Compares distributions of two global arrays. Returns 0 if distributions are identical and 1 when they are not. </p>
<p>
 </p>
<hr/>
<h3 id="COPY">COPY</h3>
<i>Copies a global array to another global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_copy</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Copies elements in array represented by g_a into the array represented by g_b. The arrays must be the same type, shape, and identically aligned. </p>
<p>
 For patch operations, the patches of arrays may be of different shapes but must have the same number of elements. Patches must be nonoverlapping (if g_a=g_b). Transposes are allowed for patch operations. </p>
<p>
 </p>
<hr/>
<h3 id="COPY_PATCH">COPY PATCH</h3>
<i>Copies a patch of a global array to another global array patch</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_copy_patch</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span>
                         <span class="n">g_b</span><span class="p">,</span> <span class="n">bilo</span><span class="p">,</span> <span class="n">bihi</span><span class="p">,</span> <span class="n">bjlo</span><span class="p">,</span> <span class="n">bjhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character</td><td>trans</td><td>transpose operator</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a, g_b</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ailo, aihi, ajlo, ajhi</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>bilo, bihi, bjlo, bjhi</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_copy_patch</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character</td><td>trans</td><td>transpose operator</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a, g_b</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Copies elements in a patch of one array into another one. The patches of arrays may be of different shapes but must have the same number of elements. Patches must be non-overlapping (if g_a=g_b). </p>
<pre>
    trans = `N' or `n' means that the transpose operator should
             not be applied.
    trans = `T' or `t' means that transpose operator should be applied.
</pre>
<p>
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#COPY">COPY</a>
<hr/>
<h3 id="CREATE">CREATE</h3>
<i>Creates a GA</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_create</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">chunk1</span><span class="p">,</span> <span class="n">chunk2</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dim1,dim2</td><td>array (dim1,dim2) as in FORTRAN</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk1,chunk2</td><td>minimum size that dimensions should be chunked up into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk(ndim)</td><td>array of chunks, each element specifies minimum size that given dimensions should be chunked up into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation was successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an ndim-dimensional array using the regular distribution model and returns an integer handle representing the array. </p>
<p>
 The array can be distributed evenly or not. The control over the distribution is accomplished by specifying chunk (block) size for all or some of array dimensions. For example, for a 2-dimensional array, setting chunk[0]=dim[0] gives distribution by vertical strips (chunk[0]*dims[0]); setting chunk[1]=dim[1] gives distribution by horizontal strips (chunk[1]*dims[1]). Actual chunks will be modified so that they are at least the size of the minimum and each process has either zero or one chunk. Specifying chunk[i] as less than 1 will cause that dimension to be distributed evenly. </p>
<p>
 As a convenience, when chunk is specified as NULL, the entire array is distributed evenly. </p>
<p>
 Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE_CONFIG">CREATE CONFIG</a>, <a target="api" href="#CREATE_GHOSTS_IRREG">CREATE GHOSTS IRREG</a>, <a target="api" href="#CREATE_GHOSTS">CREATE GHOSTS</a>, <a target="api" href="#CREATE_GHOSTS_CONFIG">CREATE GHOSTS CONFIG</a>, <a target="api" href="#CREATE_GHOSTS_IRREG_CONFIG">CREATE GHOSTS IRREG CONFIG</a>, <a target="api" href="#CREATE_HANDLE">CREATE HANDLE</a>, <a target="api" href="#CREATE_IRREG">CREATE IRREG</a>, <a target="api" href="#CREATE_IRREG_CONFIG">CREATE IRREG CONFIG</a>
<hr/>
<h3 id="CREATE_CONFIG">CREATE CONFIG</h3>
<i>Creates a GA for a specific processor group</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_config</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
                                   <span class="n">p_handle</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk(ndim)</td><td>array of chunks, each element specifies minimum size that given dimensions should be chunked up into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an ndim-dimensional array using the regular distribution model but with an explicitly specified processor group handle and returns an integer handle representing the array. </p>
<p>
This call is essentially the same as the nga_create call, except for the processor group handle p_handle. It can also be used to create mirrored arrays. </p>
<p>
Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_PGROUP">SET PGROUP</a>
<hr/>
<h3 id="CREATE_GHOSTS">CREATE GHOSTS</h3>
<i>Creates a GA with ghost cells</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_ghosts</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span>
                                   <span class="n">chunk</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>width(ndim)</td><td>array of ghost cell widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk(ndim)</td><td>array of chunks, each element specifies minimum size that given dimensions should be chunked up into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation succesful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an ndim-dimensional array with a layer of ghost cells around the visible data on each processor using the regular distribution model and returns an integer handle representing the array. </p>
<p>
 The array can be distributed evenly or not evenly. The control over the distribution is accomplished by specifying chunk (block) size for all or some of the array dimensions. For example, for a 2-dimensional array, setting chunk(1)=dim(1) gives distribution by vertical strips (chunk(1)*dims(1)); setting chunk(2)=dim(2) gives distribution by horizontal strips (chunk(2)*dims(2)). Actual chunks will be modified so that they are at least the size of the minimum and each process has either zero or one chunk. Specifying chunk(i) as < 1 will cause that dimension (i-th) to be distributed evenly. The width of the ghost cell layer in each dimension is specified using the array width(). The local data of the global array residing on each processor will have a layer width[n] ghosts cells wide on either side of the visible data along the dimension n. </p>
<p>
 Return value: a non-zero array handle means the call was successful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_GHOSTS">SET GHOSTS</a>
<hr/>
<h3 id="CREATE_GHOSTS_CONFIG">CREATE GHOSTS CONFIG</h3>
<i>Creates a GA with ghost cells and specific processor group</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_ghosts_config</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span>
                                          <span class="n">chunk</span><span class="p">,</span> <span class="n">p_handle</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>width(ndim)</td><td>array of ghost cell widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk(ndim)</td><td>array of chunks, each element specifies minimum size that given dimensions should be chunked up into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an ndim-dimensional array with a layer of ghost cells around the visible data on each processor using the regular distribution model and an explicitly specified processor list and returns an integer handle representing the array. </p>
<p>
 This call is essentially the same as the NGA_Create_ghosts call, except for the processor list handle p_handle. It can be used to create mirrored arrays. </p>
<p>
 Return value: a non-zero array handle means the call was successful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_GHOSTS">SET GHOSTS</a>, <a target="api" href="#SET_PGROUP">SET PGROUP</a>
<hr/>
<h3 id="CREATE_GHOSTS_IRREG">CREATE GHOSTS IRREG</h3>
<i>Creates an irregular-distributed GA with ghost cells</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_ghosts_irreg</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>width(ndim)</td><td>array of ghost cell widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock(ndim)</td><td>no. of blocks each dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(s)</td><td>starting index for for each block; the size s is a sum of all elements of nblock array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an array with ghost cells by following the user-specified distribution and returns an integer handle representing the array. </p>
<p>
 The distribution is specified as a Cartesian product of distributions for each dimension. </p>
<p>
 Figure "crghostir" below  demonstrates distribution of a 2-dimensional array 8x10 on 6 (or more) processors. </p>
<p>
nblock(2)={3,2}, the size of map array is s=5 and the array map contains the following elements map={1,3,7, 1, 6}. The distribution is nonuniform because, P1 and P4 get 20 elements each and processors P0, P2, P3, and P5 only 10 elements each. </p>
<p>
The array width is used to control the width of the ghost cell boundary around the visible data on each processor. The local data of the Global Array residing on each processor will have a layer width[n] ghosts cells wide on either side of the visible data along the dimension n. </p>
<p>
 Return value: a non-zero array handle means the call was succesful. </p>
<p>
 <img src="figures/create-ghosts-irreg.png" />
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_GHOSTS">SET GHOSTS</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>
<hr/>
<h3 id="CREATE_GHOSTS_IRREG_CONFIG">CREATE GHOSTS IRREG CONFIG</h3>
<i>Creates an irregular-distributed GA with ghost cells and a specific processor group</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_ghosts_irreg_config</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span>
                                                <span class="n">dims</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span>
                                                <span class="n">map</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span>
                                                <span class="n">p_handle</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>width(ndim)</td><td>array of ghost cell widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock(ndim)</td><td>no. of blocks each dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(s)</td><td>starting index for for each block; the size s is a sum of all elements of nblock array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an array with ghost cells by following the user-specified distribution and returns an integer handle representing the array. The user can specify that the array is created on a particular processor group. </p>
<p>
This call is similar to the nga_create_ghosts_irreg call. </p>
<p>
Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_GHOSTS">SET GHOSTS</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>, <a target="api" href="#SET_PGROUP">SET PGROUP</a>
<hr/>
<h3 id="CREATE_HANDLE">CREATE HANDLE</h3>
<i>Creates an inactive handle to a global array</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_create_handle</span><span class="p">()</span>
</pre></div>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 This function returns a Global Array handle that can then be used to create a new Global Array. This is part of a new API for creating Global Arrays that is designed to replace the old interface built around the NGA_Create_xxx calls. The sequence of operations is to begin with a call to GA_Greate_handle to get a new array handle. The attributes of the array, such as dimension, size, type, etc., can then be set using successive calls to the GA_Set_xxx subroutines. When all array attributes have been set, the GA_Allocate subroutine is called and the Global Array is actually created and memory for it is allocated. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>, <a target="api" href="#SET_ARRAY_NAME">SET ARRAY NAME</a>, <a target="api" href="#SET_BLOCK_CYCLIC">SET BLOCK CYCLIC</a>, <a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>, <a target="api" href="#SET_CHUNK">SET CHUNK</a>, <a target="api" href="#SET_DATA">SET DATA</a>, <a target="api" href="#SET_GHOSTS">SET GHOSTS</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>, <a target="api" href="#SET_PGROUP">SET PGROUP</a>, <a target="api" href="#SET_RESTRICTED">SET RESTRICTED</a>, <a target="api" href="#SET_RESTRICTED_RANGE">SET RESTRICTED RANGE</a>
<hr/>
<h3 id="CREATE_IRREG">CREATE IRREG</h3>
<i>Creates an irregular-distributed GA</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_create_irreg</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span>
                                 <span class="n">nblock1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">nblock2</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dim1,dim2</td><td>array (dim1,dim2) as in FORTRAN</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock1</td><td>no. of blocks first dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock2</td><td>no. of blocks second dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map1(*)</td><td>ilo for each block</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map2(*)</td><td>jlo for each block</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_irreg</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span>
                                  <span class="n">nblock</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock(ndim)</td><td>no. of blocks each dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(s)</td><td>starting index for for each block; the size s is a sum of all elements of nblock array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an array by following the user-specified distribution and returns an integer handle representing the array. </p>
<p>
 The distribution is specified as a Cartesian product of distributions for each dimension. The array indices start at 0.  For example, Figure "crirreg" below  demonstrates the distribution of a 2-dimensional 8x10 array on 6 (or more) processors. </p>
<p>
nblock(2)={3,2}, the size of the map array is s=5 and the array map contains the following elements map={1,3,7,1,6}. The distribution is nonuniform because P1 and P4 get 20 elements each and processors P0, P2, P3, and P5 only 10 elements each. </p>
<p>
<img src="figures/create-irreg.png" />
</p>
<p>
 Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>
<hr/>
<h3 id="CREATE_IRREG_CONFIG">CREATE IRREG CONFIG</h3>
<i>Creates an irregular-distributed GA with a specific processor group</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_create_irreg_config</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">array_name</span><span class="p">,</span>
                                         <span class="n">map</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">p_handle</span><span class="p">,</span> <span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,MT_DCPL,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock(ndim)</td><td>no. of blocks each dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(s)</td><td>starting index for for each block; the size s is a sum of all elements of nblock array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>integer handle for future references</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Creates an array by following the user-specified distribution and an explicitly specified processor group handle and returns an integer handle representing the array. </p>
<p>
This call is essentially the same as the nga_create_irreg call, except for the processor group handle p_handle. It can also be used to create arrays on mirrored arrays. </p>
<p>
Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE">CREATE</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>, <a target="api" href="#SET_PGROUP">SET PGROUP</a>
<hr/>
<h3 id="CREATE_MUTEXES">CREATE MUTEXES</h3>
<i>Creates mutexes</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_create_mutexes</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>number</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the world processor group.</p>
<p>
</p>
<p>
 Creates a set containing the number of mutexes. Returns 0 if the operation succeeded or 1 if it has failed. Mutex is a simple synchronization object used to protect Critical Sections. Only one set of mutexes can exist at a time. An array of mutexes can be created and destroyed as many times as needed. </p>
<p>
 Mutexes are numbered: 0, ..., number-1. </p>
<p>
 Returns: True on success, False on failure </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#DESTROY_MUTEXES">DESTROY MUTEXES</a>
<hr/>
<h3 id="DESTROY">DESTROY</h3>
<i>Destroys a global array</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_destroy</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Deallocates the array and frees any associated resources. </p>
<p>
 </p>
<hr/>
<h3 id="DESTROY_MUTEXES">DESTROY MUTEXES</h3>
<i>Destroys mutexes</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_destroy_mutexes</span><span class="p">()</span>
</pre></div>
<p>Collective on the world processor group.</p>
<p>
</p>
<p>
 Destroys the set of mutexes created with ga_create_mutexes. Returns 0 if the operation succeeded or 1 when failed. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE_MUTEXES">CREATE MUTEXES</a>
<hr/>
<h3 id="DIAG">DIAG</h3>
<i>Diagonalizes a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_diag</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_s</span><span class="p">,</span> <span class="n">g_v</span><span class="p">,</span> <span class="n">eval</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>Matrix to diagonalize</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_s</td><td>Metric</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_v</td><td>Global matrix to return evecs</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double precision</td><td>eval(*)</td><td>Local array to return evals</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Solve the generalized eigenvalue problem returning all eigenvectors and values in ascending order. The input matrices are not overwritten or destroyed. </p>
<p>
 All eigen-values as a vector in ascending order. </p>
<hr/>
<h3 id="DIAG_REUSE">DIAG REUSE</h3>
<i>Diagonalizes a global array for repeated diagonalizations</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_diag_reuse</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">g_s</span><span class="p">,</span> <span class="n">g_v</span><span class="p">,</span> <span class="n">eval</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>control</td><td>Control flag</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>Matrix to diagonalize</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_s</td><td>Metric</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_v</td><td>Global matrix to return evecs</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double precision</td><td>eval(*)</td><td>Local array to return evals</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Solve the generalized eigenvalue problem returning all eigenvectors and values in ascending order. Recommended for REPEATED calls if g_s is unchanged. Values of the control flag: </p>
<pre>
          value       action/purpose
            0          indicates first call to the eigensolver
           >0          consecutive calls (reuses factored g_s)
           <0          only erases factorized g_s; g_v and eval unchanged
                       (should be called after previous use if another
                        eigenproblem, i.e., different g_a and g_s, is to
                        be solved)
</pre>
<p>
</p>
<p>
 The input matrices are not destroyed. </p>
<p>
 Returns: All eigen-values as a vector in ascending order. </p>
<p>
 </p>
<hr/>
<h3 id="DIAG_STD">DIAG STD</h3>
<i>Diagonalizes a global array using a standard algorithm</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_diag_std</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">,</span> <span class="n">eval</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>Matrix to diagonalize</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_v</td><td>Global matrix to return evecs</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double precision</td><td>eval(*)</td><td>Local array to return evals</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Solve the standard (non-generalized) eigenvalue problem returning all eigenvectors and values in the ascending order. The input matrix is neither overwritten nor destroyed. </p>
<p>
 Returns: all eigenvectors via the g_v global array, and eigenvalues as an array in ascending order </p>
<p>
 </p>
<hr/>
<h3 id="DISTRIBUTION">DISTRIBUTION</h3>
<i>Inquires for the data range on a specified processor</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_distribution</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">iproc</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>iproc</td><td>process number</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo,ihi</td><td>i-range held by process iproc</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>jlo,jhi</td><td>j-range held by process iproc</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_distribution</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">iproc</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>iproc</td><td>process number</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim),hi(ndim)</td><td>range held by process iproc</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
This function returns the bounding indices of the block owned by the process iproc. These indices are inclusive. </p>
<p>
 If no array elements are owned by process iproc, the range is returned as lo()=0 and hi()= -1 for all dimensions. </p>
<hr/>
<h3 id="DOT">DOT</h3>
<i>Dot product of two global arrays</i>
<div class="highlight"><pre><span></span><span class="kt">double precision </span><span class="k">function </span><span class="n">ga_ddot</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
<span class="kt">double complex </span><span class="k">function </span><span class="n">ga_zdot</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Computes the element-wise dot product of the two arrays which must be of the same types and same number of elements. </p>
<p>
 Return value = SUM_ij a(i,j)*b(i,j) </p>
<p>
 </p>
<hr/>
<h3 id="DOT_PATCH">DOT PATCH</h3>
<i>Dot product of patches of global arrays</i>
<div class="highlight"><pre><span></span><span class="kt">double precision </span><span class="k">function </span><span class="n">ga_ddot_patch</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span>
                                         <span class="n">g_b</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">bilo</span><span class="p">,</span> <span class="n">bihi</span><span class="p">,</span> <span class="n">bjlo</span><span class="p">,</span> <span class="n">bjhi</span><span class="p">)</span>
<span class="kt">double complex </span><span class="k">function </span><span class="n">ga_zdot_patch</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span>
                                       <span class="n">g_b</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">bilo</span><span class="p">,</span> <span class="n">bihi</span><span class="p">,</span> <span class="n">bjlo</span><span class="p">,</span> <span class="n">bjhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ailo, aihi, ajlo, ajhi</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>bilo, bihi, bjlo, bjhi</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*1</td><td>ta, tb</td><td>transpose flags</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">double precision </span><span class="k">function </span><span class="n">nga_ddot_patch</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                          <span class="n">g_b</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">bhi</span><span class="p">)</span>
<span class="kt">double complex </span><span class="k">function </span><span class="n">nga_zdot_patch</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                        <span class="n">g_b</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*1</td><td>ta, tb</td><td>transpose flags</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Computes the element-wise dot product of the two (possibly transposed) patches which must be of the same type and have the same number of elements. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#DOT">DOT</a>
<hr/>
<h3 id="DUPLICATE">DUPLICATE</h3>
<i>Creates a new array with the same properties as the given array</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_duplicate</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">array_name</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*(*)</td><td>array_name</td><td>a character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>Integer handle for reference array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>Integer handle for new array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array creation successful</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Creates a new array by applying all the properties of another existing array. It returns an array handle. </p>
<p>
 Return value: a non-zero array handle means the call was succesful. </p>
<p>
 </p>
<hr/>
<h3 id="ELEM_DIVIDE">ELEM DIVIDE</h3>
<i>Element-wise division of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_divide</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise quotient of the two arrays which must be of the same types and same number of elements. For two-dimensional arrays, </p>
<pre>
        c(i,j) = a(i,j)/b(i,j)
</pre>
<p>
The result (c) may replace one of the input arrays (a/b).  If one of the elements of array g_b is zero, the quotient for the element of g_c will be set to GA_NEGATIVE_INFINITY. </p>
<hr/>
<h3 id="ELEM_DIVIDE_PATCH">ELEM DIVIDE PATCH</h3>
<i>Element-wise division of global array patches</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_divide_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                                <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim), chi(ndim)</td><td>g_c patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise quotient of the two patches which must be of the same types and same number of elements. For two-dimensional arrays, </p>
<pre>
        c(i,j)  = a(i,j)/b(i,j)
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<h4>See Also:</h4>
<a target="api" href="#ELEM_DIVIDE">ELEM DIVIDE</a>
<hr/>
<h3 id="ELEM_MAXIMUM">ELEM MAXIMUM</h3>
<i>Element-wise maximum of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_maximum</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise maximum of the two arrays which must be of the same types and same number of elements. For two dimensional arrays, </p>
<pre>
    c(i,j)  = max{a(i,j), b(i,j)}
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<hr/>
<h3 id="ELEM_MAXIMUM_PATCH">ELEM MAXIMUM PATCH</h3>
<i>Element-wise maximum of global array patches</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_maximum_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                 <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                                 <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim), chi(ndim)</td><td>g_c patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise maximum of the two patches which must be of the same types and same number of elements. For two-dimensional noncomplex arrays, </p>
<pre>
        c(i,j)  = max{a(i,j), b(i,j)}
</pre>
<p>
If the data type is complex, then </p>
<pre>
        c(i,j).real = max{ |a(i,j)|, |b(i,j)| } while c(i,j).image = 0.
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<hr/>
<h3 id="ELEM_MINIMUM">ELEM MINIMUM</h3>
<i>Element-wise minimum of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_minimum</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Computes the element-wise minimum of the two arrays which must be of the same types and same number of elements. For two dimensional arrays, </p>
<pre>
        c(i,j)  = min{a(i,j), b(i,j)}
</pre>
<p>
</p>
<p>
 The result (c) may replace one of the input arrays (a/b). </p>
<p>
 </p>
<hr/>
<h3 id="ELEM_MINIMUM_PATCH">ELEM MINIMUM PATCH</h3>
<i>Element-wise minimum of global array patches</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_minimum_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                 <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                                 <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim),ahi(ndim)</td><td>g_a patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim),bhi(ndim)</td><td>g_b patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim),chi(ndim)</td><td>g_c patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise minimum of the two patches which must be of the same types and same number of elements. For two-dimensional of noncomplex arrays, </p>
<pre>
        c(i,j)  = min{a(i,j), b(i,j)}
</pre>
<p>
If the data type is complex, then </p>
<pre>
        c(i,j).real = min{ |a(i,j)|, |b(i,j)| } while c(i,j).image = 0.
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<h4>See Also:</h4>
<a target="api" href="#ELEM_MINIMUM">ELEM MINIMUM</a>
<hr/>
<h3 id="ELEM_MULTIPLY">ELEM MULTIPLY</h3>
<i>Element-wise multiplication of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_multiply</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>input array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>output array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise product of the two arrays which must be of the same types and same number of elements. For two-dimensional arrays, </p>
<pre>
        c(i, j)  = a(i,j)*b(i,j)
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<p>
 </p>
<hr/>
<h3 id="ELEM_MULTIPLY_PATCH">ELEM MULTIPLY PATCH</h3>
<i>Element-wise multiplication of global array patches</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_elem_multiply_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                                  <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                                  <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>array handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim), bhi(ndim)</td><td>g_b patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim), chi(ndim)</td><td>g_c patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the element-wise product of the two patches which must be of the same types and same number of elements. For two-dimensional arrays, </p>
<pre>
        c(i,j)  = a(i,j)*b(i,j)
</pre>
<p>
The result (c) may replace one of the input arrays (a/b). </p>
<h4>See Also:</h4>
<a target="api" href="#ELEM_MULTIPLY">ELEM MULTIPLY</a>
<hr/>
<h3 id="ERROR">ERROR</h3>
<i>Aborts with an error</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character*1</td><td>message(*)</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>code</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 To be called in case of an error. Print an error message and an integer value that represents an error code as well as releasing some system resources. This is the required way of aborting the program execution. </p>
<p>
 </p>
<hr/>
<h3 id="FENCE">FENCE</h3>
<i>Fences all GA data movement operations initiated by the calling process</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_fence</span><span class="p">()</span>
</pre></div>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Blocks the calling process until all the data transfers corresponding to GA operations called after ga_init_fence complete. For example, since ga_put might return before the data reaches the final destination, ga_init_fence and ga_fence allow the process to wait until the data tranfer is fully completed: </p>
<pre>
        ga_init_fence();
        ga_put(g_a, ...);
        ga_fence();
</pre>
<p>
</p>
<p>
 ga_fence must be called after ga_init_fence. A barrier, ga_sync, assures the completion of all data transfers and implicitly cancels all outstanding ga_init_fence calls. ga_init_fence and ga_fence must be used in pairs, multiple calls to ga_fence require the same number of corresponding ga_init_fence calls. ga_init_fence/ga_fence pairs can be nested. </p>
<p>
 ga_fence works for multiple GA operations. For example: </p>
<pre>
        ga_init_fence();
        ga_put(g_a, ...);
        ga_scatter(g_a, ...);
        ga_put(g_b, ...);
        ga_fence();
</pre>
<p>
</p>
<p>
 The calling process will be blocked until data movements initiated by two calls to ga_put and one ga_scatter complete. </p>
<p>
 </p>
<hr/>
<h3 id="FILL">FILL</h3>
<i>Fills a global array with a specific value</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_fill</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>fill value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Assign a single value to all elements in the array. </p>
<p>
 </p>
<hr/>
<h3 id="FILL_PATCH">FILL PATCH</h3>
<i>Fills a patch of a global array with a specified value</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_fill_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>fill value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ailo, aihi, ajlo, ajhi</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_fill_patch</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>fill value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Fill the patch of g_a with value of `val' </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#FILL">FILL</a>
<hr/>
<h3 id="FREE_GATSCAT_BUF">FREE GATSCAT BUF</h3>
<i>Frees an internal buffer for gather/scatter operations</i>
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">nga_free_gatscat_buf</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function is used to free up internal buffers that were set with the corresponding allocation call. The buffers can be used to improve performance if multiple calls are being made to the gather/scatter operations. </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOC_GATSCAT_BUF">ALLOC GATSCAT BUF</a>
<hr/>
<h3 id="GATHER">GATHER</h3>
<i>Gathers elements from a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_gather</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision</td><td>v(n)</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>i(n), j(n), n</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_gather</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">subsArray</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of elements</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>v(n)</td><td>array containing values</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subsArray(ndim,n)</td><td>array of subscripts for each element</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Gathers array elements from a global array into a local array. The contents of the input arrays (v, subsArray) are preserved. </p>
<p>
 </p>
<pre>
for (k=0; k<= n; k++)
   {v[k] = a[subsArray[k][0]][subsArray[k][1]][subsArray[k][2]]...;}
</pre>
<p>
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#GET">GET</a>
<hr/>
<h3 id="GEMM">GEMM</h3>
<i>Performs matrix multiplication of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">GA_Dgemm</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">GA_Sgemm</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">GA_Zgemm</span><span class="p">(</span><span class="n">ta</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">g_c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, g_b</td><td>handles to input arrays</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>handle to output array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>character(1)</td><td>ta, tb</td><td>transpose operators</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>m</td><td>number of rows of op(A) and of matrix  C</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of columns of op(B) and of matrix  C</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>k</td><td>number of columns of op(A) and rows of matrix op(B)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/double complex/real</td><td>alpha, beta</td><td>scale factors</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Performs one of the matrix-matrix operations: </p>
<pre>
      C := alpha*op( A )*op( B ) + beta*C,
</pre>
<p>
</p>
<p>
 where op( X ) is one of </p>
<pre>
      op( X ) = X   or   op( X ) = X',
</pre>
<p>
</p>
<p>
 alpha and beta are scalars, and A, B, and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix. </p>
<p>
 On entry, transa specifies the form of op( A ) to be used in the matrix multiplication as follows: </p>
<pre>
           ta = `N' or `n', op( A ) = A.
           ta = `T' or `t', op( A ) = A'.
</pre>
<p>
</p>
<p>
 </p>
<hr/>
<h3 id="GET">GET</h3>
<i>Gets data from a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_get</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>buf</td><td>local buffer where data goes to</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld</td><td>leading dimension</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_get</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data goes to</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Copies data from global array section to the local array buffer. The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsistencies or errors in the input arguments are fatal. </p>
<p>
 Example: For the ga_get operation transfering data from the [10:14, 0:4] section of 2-dimensional 15x10 global array into a local buffer 5x10 array we have: </p>
<p>
 </p>
<pre>
lo={10,0,} hi={14,4}, ld={10}
</pre>
<p>
</p>
<p>
 Figure "get" below  shows the GET operation. </p>
<p>
 <img src="figures/get.png" />
</p>
<p>
 Return: The local array buffer. </p>
<p>
 </p>
<hr/>
<h3 id="GET_BLOCK_INFO">GET BLOCK INFO</h3>
<i>Returns information on block-cyclic distribution for a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_get_block_info</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="n">block_dims</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>num_blocks(ndim)</td><td>number of blocks along each axis</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>block_dims(ndim)</td><td>dimensions of block</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This subroutine returns information about the block-cyclic distribution associated with global array g_a. The number of blocks along each of the array axes are returned in the array num_blocks and the dimensions of the individual blocks, specified in the GA_Set_block_cyclic or GA_Set_block_cyclic_proc_grid subroutines, are returned in block_dims. </p>
<p>
 This is a local function. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SET_BLOCK_CYCLIC">SET BLOCK CYCLIC</a>, <a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>, <a target="api" href="#SET_TILED_PROC_GRID">SET TILED PROC GRID</a>
<hr/>
<h3 id="GET_DEBUG">GET DEBUG</h3>
<i>Returns value of GA debug flag</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_get_debug</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function returns the value of an internal flag in the GA library whose value can be set using the GA_Set_debug subroutine. </p>
<hr/>
<h3 id="GET_DIAG">GET DIAG</h3>
<i>Copies diagonal elements of a global array into another global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_get_diag</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_v</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Inserts the diagonal elements of this matrix g_a into the vector g_v. </p>
<hr/>
<h3 id="GET_GHOST_BLOCK">GET GHOST BLOCK</h3>
<i>Gets data, including ghost cells, from a global array with ghost cells</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_get_ghost_block</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data goes to</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 This operation behaves similarly to the GA Get operation and will default to a standard Get if the global array has no ghost cells or the request does not fit into the ghost cell region of the calling processor. It is easier to use than the NGA_Access_ghosts function but it may be slower and requires more memory. The operation will copy data from the locally held portions of the global array, including the ghost cells, if the requested block falls within the region defined by visible block held by the process plus the ghost cell region. For example, if the process holds the visible block [2:8, 2:8] with a ghost cell width that is one element deep, then a request for the block [1:9,1:9] will use the local ghost cells to fill the local buffer. In this case, the data transfer is completely local. If the request is for a block such as [1:10,1:10], which would require data from another process, then the NGA_Get_ghost_block call reverts to an ordinary NGA_Get operation and ignores the locally held ghost data. </p>
<p>
 Return: The local array buffer. </p>
<h4>See Also:</h4>
<a target="api" href="#GET">GET</a>, <a target="api" href="#ACCESS_GHOSTS">ACCESS GHOSTS</a>, <a target="api" href="#RELEASE_GHOSTS">RELEASE GHOSTS</a>, <a target="api" href="#RELEASE_UPDATE_GHOSTS">RELEASE UPDATE GHOSTS</a>
<hr/>
<h3 id="GOP">GOP</h3>
<i>Global commutative vector operations of elements among all processes</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_igop</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_sgop</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_dgop</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_cgop</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_zgop</span><span class="p">(</span><span class="k">type</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>type</td><td>this argument is deprecated</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>x(n)</td><td>local array of initial/final values</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>real</td><td>x(n)</td><td>local array of initial/final values</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double precision</td><td>x(n)</td><td>local array of initial/final values</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>single complex</td><td>x(n)</td><td>local array of initial/final values</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double complex</td><td>x(n)</td><td>local array of initial/final values</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>character*(*)</td><td>op</td><td>global operation</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the world processor group.</p>
<p>
</p>
<p>
 Global OPeration. </p>
<p>
 X(1:N) is a vector present on each process. GOP `sums' elements of X accross all nodes using the commutative operator OP. The result is broadcast to all nodes. Supported operations include `+', `*', `max', `min', `absmax', `absmin'. The use of lowerecase for operators is necessary. </p>
<p>
 This operation is provided only for convenience purposes: it is available regardless of the message-passing library that GA is running with. </p>
<p>
 </p>
<hr/>
<h3 id="HAS_GHOSTS">HAS GHOSTS</h3>
<i>Checks whether a GA has ghost cells</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_has_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if array has ghost cells</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function returns 1 if the global array has some dimensions for which the ghost cell width is greater than zero, it returns 0 otherwise. </p>
<p>
 </p>
<hr/>
<h3 id="INIT_FENCE">INIT FENCE</h3>
<i>Initializes tracing of completion of data movement operations</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_init_fence</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Initializes tracing of the completion status of data movement operations. </p>
<p>
 </p>
<hr/>
<h3 id="INITIALIZE">INITIALIZE</h3>
<i>Initializes GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_initialize</span><span class="p">()</span>
<span class="k">subroutine </span><span class="n">ga_initialize</span><span class="p">()</span>
</pre></div>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Allocate and initialize internal data structures in Global Arrays. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#INITIALIZE_LTD">INITIALIZE LTD</a>
<hr/>
<h3 id="INITIALIZE_LTD">INITIALIZE LTD</h3>
<i>Initializes GA with memory limit</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_initialize_ltd</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>limit</td><td>amount of memory in bytes per process</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Allocate and initialize internal data structures and set the limit for memory used in Global Arrays. The limit is per process: it is the amount of memory that the given processor can contribute to collective allocation of Global Arrays. It does not include temporary storage that GA might be allocating (and releasing) during execution of a particular operation. </p>
<p>
 *limit < 0 means "allow unlimited memory usage" in which case this operation is equivalent to GA_initialize. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#INITIALIZE">INITIALIZE</a>, <a target="api" href="#SET_MEMORY_LIMIT">SET MEMORY LIMIT</a>
<hr/>
<h3 id="INQUIRE">INQUIRE</h3>
<i>Inquires the data type and shape of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_inquire</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>dim1</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>dim2</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_inquire</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type id</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of dimensions</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns data type and dimensions of the array. </p>
<p>
 </p>
<hr/>
<h3 id="INQUIRE_MEMORY">INQUIRE MEMORY</h3>
<i>Inquires the memory used by global arrays on the calling processor</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_inquire_memory</span><span class="p">()</span>
</pre></div>
<p>
</p>
<p>
 Returns the amount of memory (in bytes) used in the allocated global arrays on the calling processor. </p>
<p>
 </p>
<hr/>
<h3 id="INQUIRE_NAME">INQUIRE NAME</h3>
<i>Inquires a global array's name</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_inquire_name</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">array_name</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*(*)</td><td>array_name</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns the name of an array represented by the handle g_a. </p>
<p>
 </p>
<hr/>
<h3 id="IS_MIRRORED">IS MIRRORED</h3>
<i>Checks whether a global array is mirrored</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="n">ga_is_mirrored</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
This subroutine checks if the array is a mirrored array or not. Returns 1 if it is a mirrored array, else it returns 0. </p>
<hr/>
<h3 id="LLT_SOLVE">LLT SOLVE</h3>
<i>Cholesky factorization of a global array</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_llt_solve</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>coefficient matrix</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>rhs/solution matrix</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Solves a system of linear equations </p>
<pre>
            A * X = B
</pre>
<p>
using the Cholesky factorization of an NxN double precision symmetric positive definite matrix A (represented by handle g_a). On successful exit B will contain the solution X. </p>
<p>
 It returns: </p>
<pre>
         = 0 : successful exit
         > 0 : the leading minor of this order is not positive
               definite and the factorization could
               not be completed.
</pre>
<p>
</p>
<p>
 </p>
<hr/>
<h3 id="LOCATE">LOCATE</h3>
<i>Locates the processor containing a specified element of a global array</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_locate</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>i, j</td><td>element subscript</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>owner</td><td>process id</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_locate</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript</td><td>element subscript</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>owner</td><td>process id</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Return the GA compute process ID that 'owns' the data. If any element of subscript[] is out of bounds "-1" is returned. </p>
<p>
 </p>
<hr/>
<h3 id="LOCATE_REGION">LOCATE REGION</h3>
<i>Locates a region of a global array</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_locate_region</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td>bounding indices for array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(5,*)</td><td>array containing mapping information</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>np</td><td>number of processors containing data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_locate_region</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">proclist</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim),hi(ndim)</td><td>region(patch) specifications</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(2*ndim,*)</td><td>patch ownership array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>proclist(np)</td><td>list of processes</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>np</td><td>number of processes containing data</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td></td><td>map(1:ndim,i)</td><td>contains lower bound dimensions for part owned by process proclist(i)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>map(ndim+1:2*ndim,i)</td><td>contains upper bound dimensions for part owned by process proclist(i)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Return a list of the GA processes ID that `own' the data. Parts of the specified patch might be actually `owned' by several processes. If lo/hi are out of bounds "0" is returned, otherwise the return value is equal to the number of processes that hold the data. </p>
<p>
</p>
<pre>
     map(1:ndim,i)            - lo(1:ndim)
     map(ndim+1:2*ndim,i)     - hi(1:ndim)
     procs(i)                 - processor id that owns data in patch
                                described by lo,hi
</pre>
<p>
</p>
<h4>See Also:</h4>
<a target="api" href="#LOCATE">LOCATE</a>
<hr/>
<h3 id="LOCK">LOCK</h3>
<i>Locks a specific mutex</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>mutex</td><td>mutex id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Locks a mutex object identified by the mutex number. It is a fatal error for a process to attempt to lock a mutex which was already locked by this process. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE_MUTEXES">CREATE MUTEXES</a>, <a target="api" href="#DESTROY_MUTEXES">DESTROY MUTEXES</a>, <a target="api" href="#UNLOCK">UNLOCK</a>
<hr/>
<h3 id="LU_SOLVE">LU SOLVE</h3>
<i>LU decomposition of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_lu_solve</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>character</td><td>trans</td><td>transpose or not transpose</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_a</td><td>coefficient matrix</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>rhs/solution matrix</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Solve the system of linear equations op(A)X = B based on the LU factorization. </p>
<p>
 op(A) = A or A' depending on the parameter trans: </p>
<pre>
     trans = `N' or `n' means that the transpose operator should not be applied.
     trans = `T' or `t' means that the transpose operator should be applied.
</pre>
<p>
</p>
<p>
 Matrix A is a general real matrix. Matrix B contains possibly multiple rhs vectors.  The array associated with the handle g_b is overwritten by the solution matrix X. </p>
<p>
 </p>
<hr/>
<h3 id="MASK_SYNC">MASK SYNC</h3>
<i>Masks GA synchronization operations</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_mask_sync</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>logical</td><td>first</td><td>mask for prior internal synchronization</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td>last</td><td>mask for post internal synchronization</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 This subroutine can be used to remove synchronization calls from around collective operations. Setting the parameter first = .false. removes the synchronization prior to the collective operation, setting last = .false. removes the synchronization call after the collective operation. This call is applicable to all collective operations.  It most be invoked before each collective operation. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SYNC">SYNC</a>
<hr/>
<h3 id="MATMUL_PATCH">MATMUL PATCH</h3>
<i>Performs matrix multiplication of patches of global arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_matmul_patch</span> <span class="p">(</span><span class="n">transa</span><span class="p">,</span> <span class="n">transb</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                            <span class="n">g_a</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span>
                            <span class="n">g_b</span><span class="p">,</span> <span class="n">bilo</span><span class="p">,</span> <span class="n">bihi</span><span class="p">,</span> <span class="n">bjlo</span><span class="p">,</span> <span class="n">bjhi</span><span class="p">,</span>
                            <span class="n">g_c</span><span class="p">,</span> <span class="n">cilo</span><span class="p">,</span> <span class="n">cihi</span><span class="p">,</span> <span class="n">cjlo</span><span class="p">,</span> <span class="n">cjhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, ailo, aihi, ajlo, ajhi</td><td>patch of g_a</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b, bilo, bihi, bjlo, bjhi</td><td>patch of g_b</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c, cilo, cihi, cjlo, cjhi</td><td>patch of g_c</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha, beta</td><td>scale factors</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*1</td><td>transa, transb</td><td>transpose operators</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_matmul_patch</span><span class="p">(</span><span class="n">transa</span><span class="p">,</span> <span class="n">transb</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                            <span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                            <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                            <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a, alo, ahi</td><td>patch of g_a</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b, blo, bhi</td><td>patch of g_b</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c, clo, chi</td><td>patch of g_c</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha, beta</td><td>scale factors</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*1</td><td>transa, transb</td><td>transpose operators</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 ga_matmul_patch is a patch version of ga_dgemm and comes in 2-D and N-D versions. The 2-D interface performs the operation: </p>
<pre>
         C[cilo:cihi,cjlo:cjhi] := alpha* AA[ailo:aihi,ajlo:ajhi] *
                                   BB[bilo:bihi,bjlo:bjhi] ) +
                                   beta*C[cilo:cihi,cjlo:cjhi],
</pre>
<p>
</p>
<p>
 where AA = op(A), BB = op(B), and op(X) is one of </p>
<pre>
      op(X) = X   or   op(X) = X',
</pre>
<p>
</p>
<p>
 Valid values for transpose arguments: 'n', 'N', 't', 'T'. It works for both double and double complex data tape. </p>
<p>
 nga_matmul_patch is a N-dimensional patch version of ga_dgemm and is similar to the 2-D interface: </p>
<pre>
      C[clo[]:chi[]] := alpha* AA[alo[]:ahi[]] *
                               BB[blo[]:bhi[]] ) + beta*C[clo[]:chi[]],
</pre>
<p>
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#GEMM">GEMM</a>
<hr/>
<h3 id="MEDIAN">MEDIAN</h3>
<i>Computes the element-wise median of three arrays</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_median</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">g_c</span><span class="p">,</span> <span class="n">g_m</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_m</td><td>output array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the componentwise Median of three arrays g_a, g_b, and g_c, and stores the result in this array g_m.  The result (m) may replace one of the input arrays (a/b/c). </p>
<hr/>
<h3 id="MEDIAN_PATCH">MEDIAN PATCH</h3>
<i>Computes the element-wise median of three global array patches</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_median_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span>
                           <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span>
                           <span class="n">g_c</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span>
                           <span class="n">g_m</span><span class="p">,</span> <span class="n">mlo</span><span class="p">,</span> <span class="n">mhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_c</td><td>input array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_m</td><td>output array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim),ahi(ndim)</td><td>g_a patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim),bhi(ndim)</td><td>g_b patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>clo(ndim),chi(ndim)</td><td>g_c patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>mlo(ndim),mhi(ndim)</td><td>g_m patch dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the componentwise Median of three patches g_a, g_b, and g_c, and stores the result in this patch g_m.  The result (m) may replace one of the input patches (a/b/c). </p>
<h4>See Also:</h4>
<a target="api" href="#MEDIAN">MEDIAN</a>
<hr/>
<h3 id="MEMORY_AVAIL">MEMORY AVAIL</h3>
<i>Inquires about memory available on the invoking processor to allocate global arrays</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_memory_avail</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns amount of memory (in bytes) left for allocation of new global arrays on the calling processor. </p>
<p>
 Note: If GA_uses_ma returns true, then GA_Memory_avail returns the lesser of the amount available under the GA limit and the amount available from MA (according to ma_inquire_avail operation). If no GA limit has been set, it returns what MA says is available. </p>
<p>
 If ( !GA_Uses_ma() && !GA_Memory_limited() ) returns < 0, indicating that the bound on currently available memory cannot be determined. </p>
<p>
 </p>
<hr/>
<h3 id="MEMORY_LIMITED">MEMORY LIMITED</h3>
<i>Checks whether memory available to GA's runtime is limited</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_memory_limited</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Indicates if limit is set on memory usage in Global Arrays on the calling processor.  "1" means "yes", "0" means "no". </p>
<p>
 Returns: True for "yes", False for "no" </p>
<p>
 </p>
<hr/>
<h3 id="MERGE_DISTR_PATCH">MERGE DISTR PATCH</h3>
<i>Merges a patched of a mirrored global array</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="n">nga_merge_distr_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim),ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>blo(ndim),bhi(ndim)</td><td>g_b patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This function merges all copies of a patch of a mirrored array (g_a) into a patch in a distributed array (g_b). </p>
<h4>See Also:</h4>
<a target="api" href="#MERGE_MIRRORED">MERGE MIRRORED</a>
<hr/>
<h3 id="MERGE_MIRRORED">MERGE MIRRORED</h3>
<i>Merges a mirrored global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_merge_mirrored</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This subroutine merges mirrored arrays by adding the contents of each array across nodes. The result is that each mirrored copy of the array represented by g_a is the sum of the individual arrays before the merge operation. After the merge, all mirrored arrays are equal. </p>
<hr/>
<h3 id="NBACC">NBACC</h3>
<i>Accumulates data into a global array without blocking the calling process</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_nbacc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo,ihi</td><td>starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>jlo,jhi</td><td>ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>buf</td><td>local buffer array where the data is</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld</td><td>leading dimension/stride/extent for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha</td><td>scale factor</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_nbacc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo[ndim]</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi[ndim]</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>buf</td><td>local buffer array where the data is</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld[ndim-1]</td><td>array specifying leading dimensions/strides/extents for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha</td><td>scale factor</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
A non-blocking version of the blocking accumulate operation. The accumulate operation can be completed locally by making a call to the wait (e.g., NGA_NbWait) routine. </p>
<p>
 Non-blocking version of ga.acc. </p>
<p>
 The accumulate operation can be completed locally by making a call to the ga.nbwait() routine. </p>
<p>
 Combines data from buffer with data in the global array patch. </p>
<p>
 The buffer array is assumed to be have the same number of dimensions as the global array. If the buffer is not contiguous, a contiguous copy will be made. </p>
<p>
 global array section (lo[],hi[]) += alpha * buffer </p>
<h4>See Also:</h4>
<a target="api" href="#ACC">ACC</a>
<hr/>
<h3 id="NBGET">NBGET</h3>
<i>Gets data from a global array without blocking the calling process</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_nbget</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo,ihi</td><td>starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>jlo,jhi</td><td>ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data goes</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld</td><td>leading dimension/stride/extent for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_nbget</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo[ndim]</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi[ndim]</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data goes</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld[ndim-1]</td><td>array specifying leading dimensions/strides/extents for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
A non-blocking version of the blocking get operation. The get operation can be completed locally by making a call to the wait (e.g., NGA_NbWait) routine. </p>
<p>
 Copies data from global array section to the local array buffer. </p>
<p>
 The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsitencies/errors in the input arguments are fatal. </p>
<p>
 Returns: The local array buffer. </p>
<h4>See Also:</h4>
<a target="api" href="#GET">GET</a>
<hr/>
<h3 id="NBLOCK">NBLOCK</h3>
<i>Inquires the number of blocks along each dimension of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_nblock</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">nblock</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock[ndim]</td><td>number of partitions for each dimension</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Given a distribution of an array represented by the handle g_a, returns the number of partitions of each array dimension. </p>
<p>
 </p>
<hr/>
<h3 id="NBPUT">NBPUT</h3>
<i>Puts data into a global array without blocking the calling process</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_nbput</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo,ihi</td><td>starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>jlo,jhi</td><td>ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>typebuf</td><td>local buffer array where the data is</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld</td><td>leading dimension/stride/extent for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_nbput</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo[ndim]</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi[ndim]</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>typebuf</td><td>local buffer array where the data is</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld[ndim-1]</td><td>array specifying leading dimensions/strides/extents for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
A non-blocking version of the blocking put operation. The put operation can be completed locally by making a call to the wait (e.g., NGA_NbWait) routine. </p>
<p>
 Copies data from local array buffer to the global array section. </p>
<p>
 The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsitencies/errors in input arguments are fatal. </p>
<h4>See Also:</h4>
<a target="api" href="#PUT">PUT</a>
<hr/>
<h3 id="NBTEST">NBTEST</h3>
<i>Tests a non-blocking GA operation for completion</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_nbtest</span><span class="p">(</span><span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if operation has completed</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_nbtest</span><span class="p">(</span><span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td></td><td>.TRUE. if operation has completed</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
This function tests a non-blocking one-sided operation for completion. If true, the function is completed locally and the buffer is available for either use or reuse, depending on the operation. Once this operation has returned true, there is no need to call nbwait on the handle. The test function is properly implemented only on the Progress Ranks and RMA runtimes. For other runtimes, it defaults to the non-blocking wait function and always returns true. </p>
<h4>See Also:</h4>
<a target="api" href="#NBWAIT">NBWAIT</a>, <a target="api" href="#_NBGET"> NBGET</a>, <a target="api" href="#NBPUT">NBPUT</a>, <a target="api" href="#NBACC">NBACC</a>
<hr/>
<h3 id="NBWAIT">NBWAIT</h3>
<i>Waits for a non-blocking GA operation to complete</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_nbwait</span><span class="p">(</span><span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_nbwait</span><span class="p">(</span><span class="n">nbhandle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>nbhandle</td><td>non-blocking request handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
This function completes a non-blocking one-sided operation locally. Waiting on a nonblocking put or an accumulate operation assures that data was injected into the network and the user buffer can now be reused. Completing a get operation assures data has arrived into the user memory and is ready for use. The wait operation ensures only local completion. Not all runtimes support true non-blocking capability. For those that don't all operations are blocking and the wait function is a no-op. </p>
<p>
 Unlike their blocking counterparts, the nonblocking operations are not ordered with respect to the destination. Performance being one reason, the other reason is that ensuring ordering would incur additional and possibly unnecessary overhead on applications that do not require their operations to be ordered. For cases where ordering is necessary, it can be done by calling a fence operation. The fence operation is provided to the user to confirm remote completion if needed. </p>
<h4>See Also:</h4>
<a target="api" href="#NBTEST">NBTEST</a>, <a target="api" href="#NBGET">NBGET</a>, <a target="api" href="#NBPUT">NBPUT</a>, <a target="api" href="#NBACC">NBACC</a>
<hr/>
<h3 id="NDIM">NDIM</h3>
<i>Inquires the number of dimensions in a global array</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_ndim</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns the number of dimensions in the array represented by the handle g_a. </p>
<p>
 </p>
<hr/>
<h3 id="NNODES">NNODES</h3>
<i>Returns the total number of GA ranks</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_nnodes</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns the number of the GA compute (user) processes. </p>
<p>
 </p>
<hr/>
<h3 id="NODEID">NODEID</h3>
<i>Returns the GA rank of the invoking process</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_nodeid</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns the GA process id (0, ..., ga_Nnodes()-1) of the requesting compute process. </p>
<p>
 </p>
<hr/>
<h3 id="NORM_INFINITY">NORM INFINITY</h3>
<i>Computes a global array's infinite norm</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_norm_infinity</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">nm</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision</td><td>nm</td><td>matrix/vector infinity-norm value</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the infinity-norm of the matrix or vector g_a. </p>
<hr/>
<h3 id="NORM1">NORM1</h3>
<i>Computes a global array's 1-norm</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_norm1</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">nm</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision</td><td>nm</td><td>matrix/vector 1-norm value</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Computes the 1-norm of the matrix or vector g_a. </p>
<hr/>
<h3 id="OVERLAY">OVERLAY</h3>
<i>Create a global array on top of an existing allocation</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_overlay</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_p</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>handle for overlay array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_p</td><td>handle for parent array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
The overlay function is designed to allow users to create a global array on top of an existing global array. This can be used in situations where it is desirable to create and destroy a large number of global arrays in rapid succession and where the size of these global arrays can be bounded beforehand. A large global array is created at the start using conventional create or allocate calls and then is used as the parent for new global arrays that are allocated using the overlay call. This approach removes some collectives and memory allocation and deallocation calls from the process of creating a global array and should result in improved performance. Note that the parent global array should not be used while another array is overlayed on top of it. </p>
<p>Collective on the processor group inferred from the arguments.</p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>
<hr/>
<h3 id="PACK">PACK</h3>
<i>Compresses values from a source vector based on a corresponding integer mask</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_pack</span><span class="p">(</span><span class="n">g_src</span><span class="p">,</span> <span class="n">g_dest</span><span class="p">,</span> <span class="n">g_mask</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">icount</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_src</td><td>handle for source array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_dest</td><td>handle for destination array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>g_mask</td><td>handle for integer array representing a bit mask</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo,hi</td><td>low and high values of range on which operation is performed</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>icount</td><td>number of values in compressed array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
The pack subroutine is designed to compress the values in the source vector g_src into a smaller destination array g_dest based on the values in an integer mask array g_mask. The values lo and hi denote the range of elements that should be compressed and icount is a variable that on output lists the number of values placed in the compressed array. This operation is the complement of the GA_Unpack operation. An example is shown below </p>
<pre>
GA_Pack(g_src, g_dest, g_mask, 1, n, &icount);

g_mask:   1  0  0  0  0  0  1  0  1  0  0  1  0  0  1  1  0
g_src:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
g_dest:   1  7  9 12 15 16
icount:   6
</pre>
<p>
</p>
<p>
 The current implementation requires that the distribution of the g_mask array matches the distribution of the g_src array. </p>
<hr/>
<h3 id="PATCH_ENUM">PATCH ENUM</h3>
<i>Enumerates a global array patch</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_patch_enum</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo,hi</td><td>low and high values of array patch</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>start</td><td>integer/double precision/complex starting value of enumeration</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>inc</td><td>integer/double precision/complex increment value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This subroutine enumerates the values of an array between elements lo and hi starting with the value start and incrementing each subsequent value by inc. This operation is only applicable to 1-dimensional arrays. An example of its use is shown below: </p>
<pre>
GA_Patch_enum(g_a, 1, n, 7, 2);

g_a:  7  9 11 13 15 17 19 21 23 ...
</pre>
<p>
</p>
<hr/>
<h3 id="PERIODIC_ACC">PERIODIC ACC</h3>
<i>Accumulates data into a global array using periodic boundary conditions</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_periodic_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the local data is</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>alpha</td><td>scale argument for accumulate</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Same as nga_acc except the indices can extend beyond the array boundary/dimensions in which case the library wraps them around. For Python, this is the periodic version of ga.acc. </p>
<p>
 Combines data from buffer with data in the global array patch. </p>
<p>
 The buffer array is assumed to be have the same number of dimensions as the global array. If the buffer is not contiguous, a contiguous copy will be made. </p>
<p>
 global array section (lo[],hi[]) += alpha * buffer </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACC">ACC</a>
<hr/>
<h3 id="PERIODIC_GET">PERIODIC GET</h3>
<i>Gets data from a global array using periodic boundary conditions</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_periodic_get</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span>  <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data goes  to</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Same as nga_get except the indices can extend beyond the array boundary/dimensions in which case the library wraps them around. </p>
<p>
 The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsitencies/errors in the input arguments are fatal. </p>
<p>
 Returns: The local Array buffer. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#GET">GET</a>
<hr/>
<h3 id="PERIODIC_PUT">PERIODIC PUT</h3>
<i>Puts data into a global array using periodic boundary conditions</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_periodic_put</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span>  <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data comes from</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Same as nga_put except the indices can extend beyond the array boundary/dimensions in which case the library wraps them around.  The indices can extend beyond the array boundary/dimensions in which case the libray wraps them around.  Copies data from local array buffer to the global array section. The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsitencies/errors in input arguments are fatal. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PUT">PUT</a>
<hr/>
<h3 id="PGROUP_BRDCST">PGROUP BRDCST</h3>
<i>Broadcasts elements among processes in a processor group</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_pgroup_brdcst</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">lenbuf</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>message index</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>byte</td><td>buf(lenbuf)</td><td>local message buffer</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>lenbuf</td><td>length of message</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>root</td><td>processor sending message</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Broadcast data from processor specified by root to all other processors in the processor group specified by p_handle. The length of the message in bytes is specified by lenbuf. The initial and broadcasted data can be found in the buffer specified by the pointer buf. </p>
<p>
 If the buffer is not contiguous, an error is raised. This operation is provided only for convenience purposes: it is available regardless of the message-passing library that GA is running with. </p>
<p>
 Returns: The buffer in case a temporary was passed in. </p>
<h4>See Also:</h4>
<a target="api" href="#BRDCST">BRDCST</a>
<hr/>
<h3 id="PGROUP_CREATE">PGROUP CREATE</h3>
<i>Creates a GA processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_create</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>size</td><td>number of processors in group</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>list(size)</td><td>list of processors in processor group</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td></td><td>pgroup handle</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 This command is used to create a processor group. At present, it must be invoked by all processors in the current default processor group. The list of processors use the indexing scheme of the default processor group. If the default processor group is the world group, then these indices are the usual processor indices. This function returns a process group handle that can be used to reference this group by other functions. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PGROUP_DESTROY">PGROUP DESTROY</a>, <a target="api" href="#PGROUP_SET_DEFAULT">PGROUP SET DEFAULT</a>
<hr/>
<h3 id="PGROUP_DESTROY">PGROUP DESTROY</h3>
<i>Destroys a GA processor group</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_pgroup_destroy</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td></td><td>.FALSE. if processor group was not previously active</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This command is used to free up a processor group handle. It returns 0 if the processor group handle was not previously active. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PGROUP_CREATE">PGROUP CREATE</a>, <a target="api" href="#PGROUP_SET_DEFAULT">PGROUP SET DEFAULT</a>
<hr/>
<h3 id="PGROUP_DUPLICATE">PGROUP DUPLICATE</h3>
<i>Duplicate an existing GA processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_duplicate</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td></td><td>handle to new processor group</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>
</p>
<p>
 Return a copy of an existing processor group. </p>
<p>
 </p>
<p>Collective on the processor group inferred from the arguments.</p>
<h4>See Also:</h4>
<a target="api" href="#PGROUP_CREATE">PGROUP CREATE</a>
<hr/>
<h3 id="PGROUP_GET_DEFAULT">PGROUP GET DEFAULT</h3>
<i>Sets default GA processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_get_default</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function will return a handle to the default processor group, which can then be used to create a global array using one of the NGA_create_*_config or GA_Set_pgroup calls. </p>
<hr/>
<h3 id="PGROUP_GET_MIRROR">PGROUP GET MIRROR</h3>
<i>Gets the mirrored processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_get_mirror</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function will return a handle to the mirrored processor group, which can then be used to create a global array using one of the NGA_create_*_config or GA_Set_pgroup calls. </p>
<hr/>
<h3 id="PGROUP_GET_WORLD">PGROUP GET WORLD</h3>
<i>Gets the world processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_get_world</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function will return a handle to the world processor group, which can then be used to create a global array using one of the NGA_create_*_config or GA_Set_pgroup calls. </p>
<hr/>
<h3 id="PGROUP_GOP">PGROUP GOP</h3>
<i>Global operation with a processor group</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_pgroup_igop</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_pgroup_sgop</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_pgroup_dgop</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_pgroup_cgop</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">ga_pgroup_zgop</span><span class="p">(</span><span class="n">p_handle</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>message index (deprecated)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>buf(n)</td><td>array</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>real</td><td>buf(n)</td><td>array</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double precision</td><td>buf(n)</td><td>array</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>single complex</td><td>buf(n)</td><td>array</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>double complex</td><td>buf(n)</td><td>array</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>n</td><td>number elements in array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*(*)</td><td>op</td><td>operation on data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
The buf[n] is an array present on each processor in the processor group p_handle. The GA_Pgroup_dgop `sums' all elements in buf[n] across all processors in the group specified by p_handle using the commutative operation specified by the character string op.  The result is broadcast to all processor in p_handle. Allowed strings are `+', `*', `max', `min', `absmax', `absmin'. The use of lowerecase for operators is necessary. </p>
<h4>See Also:</h4>
<a target="api" href="#GOP">GOP</a>
<h4>See Also:</h4>
<a target="api" href="#GOP">GOP</a>
<hr/>
<h3 id="PGROUP_NNODES">PGROUP NNODES</h3>
<i>Returns number of GA ranks in a processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_nnodes</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
This function returns the number of processors contained in the group specified by p_handle. </p>
<p>
 Returns the number of processors contained in the group specified by pgroup. </p>
<h4>See Also:</h4>
<a target="api" href="#NNODES">NNODES</a>
<hr/>
<h3 id="PGROUP_NODEID">PGROUP NODEID</h3>
<i>Returns GA rank of invoking process in a processor group</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_nodeid</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
This function returns the relative index of the processor in the processor group specified by p_handle. This index will generally differ from the absolute processor index returned by GA_Nodeid if the processor group is not the world group. </p>
<p>
 Returns the relative index of the processor in the processor group specified by pgroup. </p>
<h4>See Also:</h4>
<a target="api" href="#NODEID">NODEID</a>
<hr/>
<h3 id="PGROUP_SELF">PGROUP SELF</h3>
<i>Create a process group with only the calling process in it</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_pgroup_self</span><span class="p">()</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td></td><td>handle to new processor group</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>
</p>
<p>
 Return a processor group that only contains the calling process. </p>
<p>
 </p>
<p>One-sided (non-collective).</p>
<h4>See Also:</h4>
<a target="api" href="#PGROUP_CREATE">PGROUP CREATE</a>
<hr/>
<h3 id="PGROUP_SET_DEFAULT">PGROUP SET DEFAULT</h3>
<i>Sets a default GA processor group</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_pgroup_set_default</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to reset the default processor group on a collection of processors. All processors in the group referenced by p_handle must make a call to this function. Any standard global array call that is made after resetting the default processor group will be restricted to processors in that group. Global arrays that are created after resetting the default processor group will only be defined on that group and global operations, such as GA_Sync or GA_Igop, and will be restricted to processors in that group. The GA_Pgroup_set_default call can be used to rapidly convert large applications, written with GA, into routines that run on processor groups. </p>
<p>
 The default processor group can be overridden by using GA calls that require an explicit group handle as one of the arguments. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PGROUP_CREATE">PGROUP CREATE</a>, <a target="api" href="#PGROUP_DESTROY">PGROUP DESTROY</a>
<hr/>
<h3 id="PGROUP_SYNC">PGROUP SYNC</h3>
<i>Synchronizes processes in a processor group</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_pgroup_sync</span><span class="p">(</span><span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This operation executes a synchronization group across the processors in the processor group specified by p_handle. Nodes outside this group are unaffected. </p>
<h4>See Also:</h4>
<a target="api" href="#SYNC">SYNC</a>
<hr/>
<h3 id="PRINT">PRINT</h3>
<i>Prints the contents of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_print</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Prints an entire array to the standard output. </p>
<p>
 </p>
<hr/>
<h3 id="PRINT_DISTRIBUTION">PRINT DISTRIBUTION</h3>
<i>Prints the distribution of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_print_distribution</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Prints the array distribution. </p>
<p>
 </p>
<hr/>
<h3 id="PRINT_FILE">PRINT FILE</h3>
<i>Prints the contents of a global array to a file</i>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Prints an entire array to a file. </p>
<p>
 </p>
<hr/>
<h3 id="PRINT_PATCH">PRINT PATCH</h3>
<i>Prints a patch of a global array to stdout</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_print_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span><span class="n">ilo</span><span class="p">,</span><span class="n">ihi</span><span class="p">,</span><span class="n">jlo</span><span class="p">,</span><span class="n">jhi</span><span class="p">,</span><span class="n">pretty</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo,ihi,jlo,jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>pretty</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Prints a patch of g_a array to the standard output. If the variable pretty has the value 0 then output is printed in a dense fashion. If pretty has the value 1 then output is formatted and rows/columns are labeled. </p>
<p>
 </p>
<hr/>
<h3 id="PRINT_STATS">PRINT STATS</h3>
<i>Prints GA runtime statistics</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_print_stats</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 This non-collective (MIMD) operation prints information about: <ul>
<li>Number of calls to the GA create/duplicate, destroy, get, put, scatter, gather, and read_and_inc operations</li>
<li>Total amount of data moved in the GA primitive operations</li>
<li>Amount of data moved in GA primitive operations to logicaly remote locations</li>
<li>Maximum memory consumption in global arrays, and</li>
<li>Number of requests serviced in the interrupt-driven implementations by the calling process.</li>
</ul>
</p>
<p>
 </p>
<hr/>
<h3 id="PROC_TOPOLOGY">PROC TOPOLOGY</h3>
<i>Inquires the linear location of a processor in the processor topology employed by a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_proc_topology</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">prow</span><span class="p">,</span> <span class="n">pcol</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>proc</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>prow, pcol</td><td></td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Based on the distribution of an array associated with handle g_a, determines coordinates of the specified processor in the virtual processor grid corresponding to the distribution of array g_a. The numbering starts from 0. The values of -1 means that the processor doesn't "own" any section of the array represented by g_a. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>
<hr/>
<h3 id="PUT">PUT</h3>
<i>Puts data into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_put</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td>bounding indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>buf</td><td>local buffer where data comes from</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_put</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data comes from</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Copies data from the local array buffer to the global array section. The local array is assumed to have the same number of dimensions as the global array. Any detected inconsistencies or errors in input arguments are fatal. </p>
<p>
 </p>
<hr/>
<h3 id="READ_INC">READ INC</h3>
<i>Atomically read and increment an element in a global array</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_read_inc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>i, j, inc</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">nga_read_inc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>subscript</td><td>(ndim)</td><td>subscript array for the referenced element</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>inc</td><td></td><td>amount element is incremented after read</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Atomically read and increment an element in an integer array. </p>
<p>
 </p>
<pre>
   *BEGIN CRITICAL SECTION*
   old_value = a(subscript)
   a(subscript) += inc
   *END CRITICAL SECTION*
   return old_value
</pre>
<p>
</p>
<p>
 </p>
<hr/>
<h3 id="RECIP">RECIP</h3>
<i>Translates a global array to contain reciprocal of its elements</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_recip</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Take the element-wise reciprocal of the array. </p>
<hr/>
<h3 id="RECIP_PATCH">RECIP PATCH</h3>
<i>Translates a global array patch to contain reciprocal of its elements</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_recip_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim), hi(ndim)</td><td>patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Take element-wise reciprocal of the patch. </p>
<h4>See Also:</h4>
<a target="api" href="#RECIP">RECIP</a>
<hr/>
<h3 id="RELEASE">RELEASE</h3>
<i>Releases access to a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_release</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim),hi(ndim)</td><td>patch specification</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to a global array when the data was read only. </p>
<p>
 Your code should look like: </p>
<pre>
        NGA_Distribution(g_a, myproc, lo,hi);
        NGA_Access(g_a, lo, hi, \&ptr, ld);

             <operate on the data referenced by ptr>
        GA_Release(g_a, lo, hi);
</pre>
<p>
NOTE: see restrictions specified for ga_access. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>
<hr/>
<h3 id="RELEASE_BLOCK">RELEASE BLOCK</h3>
<i>Releases access to a block of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_block</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="nb">index</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>block index</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of data specified by the integer index when data was accessed as read only. This is only applicable to block-cyclic data distributions created using the simple block-cyclic distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK">ACCESS BLOCK</a>
<hr/>
<h3 id="RELEASE_BLOCK_GRID">RELEASE BLOCK GRID</h3>
<i>Releases access to a block-cyclic distributed global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_block_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>indices of block in array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of data specified by the subscript array when data was accessed as read only. This is only applicable to block-cyclic data distributions created using the SCALAPACK data distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK_GRID">ACCESS BLOCK GRID</a>
<hr/>
<h3 id="RELEASE_BLOCK_SEGMENT">RELEASE BLOCK SEGMENT</h3>
<i>Releases access to a block in a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_block_segment</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">iproc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>iproc</td><td>processor ID</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of locally held data for a block-cyclic array, when data was accessed as read-only. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK_SEGMENT">ACCESS BLOCK SEGMENT</a>
<hr/>
<h3 id="RELEASE_GHOST_ELEMENT">RELEASE GHOST ELEMENT</h3>
<i>Releases access to ghost cells in a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_ghost_element</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>element subscript</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the locally held data for an array with ghost elements, when data was accessed as read-only. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_GHOST_ELEMENT">ACCESS GHOST ELEMENT</a>
<hr/>
<h3 id="RELEASE_GHOSTS">RELEASE GHOSTS</h3>
<i>Releases access to ghost cells</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the locally held block of data containing ghost elements, when data was accessed as read-only. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_GHOSTS">ACCESS GHOSTS</a>
<hr/>
<h3 id="RELEASE_UPDATE">RELEASE UPDATE</h3>
<i>Releases access to a global array after an update</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_release_update</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ilo</span><span class="p">,</span> <span class="n">ihi</span><span class="p">,</span> <span class="n">jlo</span><span class="p">,</span> <span class="n">jhi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ilo, ihi, jlo, jhi</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim),hi(ndim)</td><td>patch specification</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the data. It must be used if the data was accessed for writing. </p>
<p>
 NOTE: see restrictions specified for ga_access. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS">ACCESS</a>
<hr/>
<h3 id="RELEASE_UPDATE_BLOCK">RELEASE UPDATE BLOCK</h3>
<i>Releases after update access to a block in a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update_block</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="nb">index</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>index</td><td>block index</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of data specified by the integer index when data was accessed in read-write mode. This is only applicable to block-cyclic data distributions created using the simple block-cyclic distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK">ACCESS BLOCK</a>
<hr/>
<h3 id="RELEASE_UPDATE_BLOCK_GRID">RELEASE UPDATE BLOCK GRID</h3>
<i>Releases after update access to a block in a block-cyclic distributed global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update_block_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>indices of block in array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of data specified by the subscript array when data was accessed in read-write mode. This is only applicable to block-cyclic data distributions created using the SCALAPACK data distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK_GRID">ACCESS BLOCK GRID</a>
<hr/>
<h3 id="RELEASE_UPDATE_BLOCK_SEGMENT">RELEASE UPDATE BLOCK SEGMENT</h3>
<i>Releases access to a block of a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update_block_segment</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">iproc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>iproc</td><td>processor ID</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the block of locally held data for a block-cyclic array, when data was accessed as read-only. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_BLOCK_SEGMENT">ACCESS BLOCK SEGMENT</a>
<hr/>
<h3 id="RELEASE_UPDATE_GHOST_ELEMENT">RELEASE UPDATE GHOST ELEMENT</h3>
<i>Releases after update access to ghost cells in a GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update_ghost_element</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">subscript</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subscript(ndim)</td><td>element subscript</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the locally held data for an array with ghost elements, when data was accessed in read-write mode. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_GHOST_ELEMENT">ACCESS GHOST ELEMENT</a>
<hr/>
<h3 id="RELEASE_UPDATE_GHOSTS">RELEASE UPDATE GHOSTS</h3>
<i>Releases after access to ghosts</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_release_update_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Releases access to the locally held block of data containing ghost elements, when data was accessed in read-write mode. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACCESS_GHOSTS">ACCESS GHOSTS</a>
<hr/>
<h3 id="SCALE">SCALE</h3>
<i>Scales a global array by the specified value</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scale</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>scale factor</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Scales an array by the constant s. Note that the library is unable to detect errors when the pointed value is of a different type than the array. </p>
<p>
 </p>
<hr/>
<h3 id="SCALE_COLS">SCALE COLS</h3>
<i>Scales columns of a global array with elements in another gobal array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scale_cols</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_v</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Scales the columns of this matrix g_a using the vector g_v. </p>
<hr/>
<h3 id="SCALE_PATCH">SCALE PATCH</h3>
<i>Scales elements in the patch of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scale_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ailo</span><span class="p">,</span> <span class="n">aihi</span><span class="p">,</span> <span class="n">ajlo</span><span class="p">,</span> <span class="n">ajhi</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>scale factor</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ailo, aihi, ajlo, ajhi</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_scale_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex/integer</td><td>s</td><td>scale factor</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Scale an array by the factor `val' </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SCALE">SCALE</a>
<hr/>
<h3 id="SCALE_ROWS">SCALE ROWS</h3>
<i>Scales the rows of a global array with elements in another global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scale_rows</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_v</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Scales the rows of this matrix g_a using the vector g_v. </p>
<hr/>
<h3 id="SCAN_ADD">SCAN ADD</h3>
<i>Adds successive elements in a source vector based on a corresponding intenger mask</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scan_add</span><span class="p">(</span><span class="n">g_src</span><span class="p">,</span> <span class="n">g_dest</span><span class="p">,</span> <span class="n">g_mask</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">excl</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_src</td><td>handle for source array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_dest</td><td>handle for destination array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>g_mask</td><td>handle for integer array representing a bit mask</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo,hi</td><td>low and high values of range on which operation is performed</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>excl</td><td>value to signify if masked values are included in add</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This operation will add successive elements in a source vector g_src and put the results in a destination vector g_dest. The addition will restart based on the values of the integer mask vector g_mask. The scan is performed within the range specified by the integer values lo and hi. Note that this operation can only be applied to 1-dimensional arrays. The excl flag determines whether the sum starts with the value in the source vector corresponding to the location of a 1 in the mask vector (excl=0) or whether the first value is set equal to 0 (excl=1). Some examples of this operation are given below. </p>
<pre>
GA_Scan_add(g_src, g_dest, g_mask, 1, n, 0);

g_mask:   1  0  0  0  0  0  1  0  1  0  0  1  0  0  1  1  0
g_src:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
g_dest:   1  3  6 10 16 21  7 15  9 19 30 12 25 39 15 16 33

GA_Scan_add(g_src, g_dest, g_mask, 1, n, 1);

g_mask:   1  0  0  0  0  0  1  0  1  0  0  1  0  0  1  1  0
g_src:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
g_dest:   0  1  3  6 10 15  0  7  0  9 19  0 12 25  0  0 16
</pre>
<p>
</p>
<hr/>
<h3 id="SCAN_COPY">SCAN COPY</h3>
<i>Copies successive elements in a source vector based on a corresponding intenger mask</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scan_copy</span><span class="p">(</span><span class="n">g_src</span><span class="p">,</span> <span class="n">g_dest</span><span class="p">,</span> <span class="n">g_mask</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_src</td><td>handle for source array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_dest</td><td>handle for destination array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>g_mask</td><td>handle for integer array representing a bit mask</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo,hi</td><td>low and high values of range on which operation is performed</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This subroutine does a segmented scan-copy of values in the source array g_src into a destination array g_dest with segments defined by values in the integer mask array g_mask. The scan-copy operation is only applied to the range between the lo and hi indices. This operation is restriced to 1-dimensional arrays. The resulting destination array will consist of segments of consecutive elements with the same value. An example is shown below. </p>
<pre>
GA_Scan_copy(g_src, g_dest, g_mask, 1, n);

g_mask:   1  0  0  0  0  0  1  0  1  0  0  1  0  0  1  1  0
g_src:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
g_dest:   1  1  1  1  1  1  7  7  9  9  9 12 12 12 15 16 16

</pre>
<p>
</p>
<hr/>
<h3 id="SCATTER">SCATTER</h3>
<i>Scatters elements into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scatter</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision</td><td>v(n)</td><td>vector of values to be scattered</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>i(n), j(n)</td><td>array of subscripts for each destination element</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of elements to be scattered</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_scatter</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">subsArray</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of elements</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>v(n)</td><td>array containing values</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subsArray(ndim,n)</td><td>array of subscripts for each element</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Scatters array elements into a global array. The contents of the input arrays (v,subsArray) are preserved. </p>
<p>
 </p>
<pre>
for (k=0; k<= n; k++)
   {a[[subsArray[k][0]][subsArray[k][1]][subsArray[k][2]]... = v[k];}
</pre>
<p>
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PUT">PUT</a>
<hr/>
<h3 id="SCATTER_ACC">SCATTER ACC</h3>
<i>Scatters and accumulates elements into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_scatter_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of elements</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>v(n)</td><td>array containing value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>i(n),j(n)</td><td>arrays of indices</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha</td><td>multiplicative value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_scatter_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">subsArray</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>n</td><td>number of elements</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>v(n)</td><td>array containing value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>subsArray(ndim,n)</td><td>array of subscripts</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision/complex</td><td>alpha</td><td>multiplicative value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Scatters array elements from a local array into a global array. Adds values from the local array to existing values in the global array after multiplying by alpha. The contents of the input arrays (v, subsArray) are preserved. </p>
<p>
 </p>
<pre>
for (k=0; k<= n; k++)
   {a[subsArray[k][0]][subsArray[k][1]][subsArray[k][2]]... += v[k];}
</pre>
<p>
</p>
<p>
 Like scatter, but adds values to existing values in the global array after multiplying by alpha. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACC">ACC</a>
<hr/>
<h3 id="SELECT_ELEM">SELECT ELEM</h3>
<i>Selects an element in a global returned by the chosen operation (eg., min, max, etc.)</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_select_elem</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">index</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle Control</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character(*)*</td><td>op</td><td>operator {`min',`max'}</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>val</td><td>address where selected value should be stored</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>index(ndim)</td><td>array index for the selected element</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Returns the value and index for an element that is selected by the specified operator ("min" or "max") in a global array corresponding to g_a handle. </p>
<p>
 </p>
<hr/>
<h3 id="SET_ARRAY_NAME">SET ARRAY NAME</h3>
<i>Specifies what the name will be for the GA handle</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_array_name</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>character*(*)</td><td>name</td><td>a unique character string</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to assign a unique character string name to a Global Array handle that was obtained using the GA_Create_handle function. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>
<hr/>
<h3 id="SET_BLOCK_CYCLIC">SET BLOCK CYCLIC</h3>
<i>Specifies GA handle will have a round-robin distribution</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_block_cyclic</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of block dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This subroutine is used to create a global array with a simple block-cyclic data distribution. The array is broken up into blocks of size dims and each block is numbered sequentially using a column major indexing scheme. The blocks are then assigned in a simple round-robin fashion to processors. </p>
<p>
 Figure "stblkcy" below  illustrates an array containing 25 blocks distributed on 4 processors. </p>
<p>
 Blocks at the edge of the array may be smaller than the block size specified in dims. In the example below, blocks 4, 9, 14, 19, 20, 21, 22, 23, and 24 might be smaller than the remaining blocks. Most global array operations are insensitive to whether or not a block-cyclic data distribution is used, although performance may be slower in some cases if the global array is using a block-cyclic data distribution. Individual data blocks can be accessesed using the block-cyclic access functions. </p>
<p>
 <img src="figures/set-block-cyclic.png" />
</p>
<p>
 </p>
<hr/>
<h3 id="SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</h3>
<i>Specifies the GA handle will have a block-cyclic processor distribution</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_block_cyclic_proc_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">proc_grid</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array of block dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This subroutine is used to create a global array with a SCALAPACK-type block cyclic data distribution. The user specifies the dimensions of the processor grid in the array proc_grid. The product of the processor grid dimensions must equal the number of total number of processors and the number of dimensions in the processor grid must be the same as the number of dimensions in the global array. The data blocks are mapped onto the processor grid in a cyclic manner along each of the processor grid axes. </p>
<p>
 Figure "setblkcyprocgrid" below  illustrates an array consisting of 25 data blocks distributed on 6 processors. </p>
<p>
 The 6 processors are configured in a 3 by 2 processor grid. Blocks at the edge of the array may be smaller than the block size specified in dims.  Most global array operations  are insensitive to whether or not a block-cyclic data distribution is used, although performance may be slower in some cases if the global array is using a block-cyclic data distribution. Individual data blocks can be accessesed using the block-cyclic access functions. </p>
<p>
 <img src="figures/set-block-cyclic-proc-grid.png" />
</p>
<p>
 </p>
<hr/>
<h3 id="SET_CHUNK">SET CHUNK</h3>
<i>Specifies GA handle will have the given chunk size</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_chunk</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>chunk(ndim)</td><td>array of chunk widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function is used to set the chunk array for a global array handle that was obtained using the GA_Create_handle function. The chunk array is used to determine the minimum number of array elements assigned to each processor along each coordinate direction. </p>
<p>
 </p>
<hr/>
<h3 id="SET_DATA">SET DATA</h3>
<i>Specifies what the array shape and data type wlll be for a GA handle</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_data</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="k">type</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>dimension of array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dims(ndim)</td><td>array dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>type</td><td>data type (MT_DBL,MT_INT,etc.)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to set the array dimension, the coordinate dimensions, and the data type assigned to a Global Array handle obtained using the GA_Create_handle function. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>
<hr/>
<h3 id="SET_DEBUG">SET DEBUG</h3>
<i>Sets GA debug flag</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_debug</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>logical</td><td>flag</td><td>value to set internal debug flag</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
This function sets an internal flag in the GA library to either true or false. The value of this flag can be recovered at any time using the GA_Get_debug function. The flag is set to false when the the GA library is initialized. This can be useful in a number of debugging situations, especially when examining the behavior of routines that are called in multiple locations in a code. </p>
<hr/>
<h3 id="SET_DIAGONAL">SET DIAGONAL</h3>
<i>Sets the diagonal elements of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_diagonal</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_v</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_v</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Sets the diagonal elements of this matrix g_a with the elements of the vector g_v. </p>
<hr/>
<h3 id="SET_GHOSTS">SET GHOSTS</h3>
<i>Specifies the GA handle will have ghost cells</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>width(ndim)</td><td>array of ghost cell widths</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to set the ghost cell widths for a global array handle that was obtained using the GA_Create_handle function.  The ghosts cells widths indicate how many ghost cells are used to pad the locally held array data along each dimension. The padding can be set independently for each coordinate dimension. </p>
<p>
 </p>
<hr/>
<h3 id="SET_IRREG_DISTR">SET IRREG DISTR</h3>
<i>Specifies that the GA handle will have an irregular distribution</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_irreg_distr</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">mapc</span><span class="p">,</span> <span class="n">nblock</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>map(s)</td><td>starting index for for each block; the size s is a sum of all elements of nblock array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblock(ndim)</td><td>no. of blocks each dimension is divided into</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to partition the array data among the individual processors for a global array handle obtained using the GA_Create_handle function. </p>
<p>
The distribution is specified as a Cartesian product of distributions for each dimension. For example, the following figure demonstrates the distribution of a 2-dimensional array 8x10 on 6 processors. nblock(2)={3,2}, the size of mapc array is s=5 and array mapc contains the following elements mapc={1, 3, 7, 1, 6}. The distribution is nonuniform because, P1 and P4 get 20 elements each and processors P0, P2, P3, and P5 only 10 elements each. </p>
<p>
The array width() is used to control the width of the ghost cell boundary around the visible data on each processor. The local data of the global array residing on each processor will have a layer width(n) ghosts cells wide on either side of the visible data along the dimension n. </p>
<p>
 An example is shown in Figure "setirregdist" below . </p>
<p>
 <img src="figures/set-irreg-dist.png" />
</p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>
<hr/>
<h3 id="SET_MEMORY_DEV">SET MEMORY DEV</h3>
<i>Specify the type of memory used for the global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_memory_dev</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>character*(*)</td><td>character string specifying the memory type</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function allows users to specify what type of memory is used for allocating global arrays. This functionality relies on the Simpified Interface for Complex Memory library, available at <a href = "https://github.com/lanl/SICM" target="_blank">https://github.com/lanl/SICM</a>. If Global Arrays is not linked to SICM, then this property is ignored and the array will be allocated on ordinary memory. This should still produce correct code, but performance may be lower. </p>
<p>
 The type of memory available depends on the hardware being used. Currently supported options are "dram" (this is widely available but only corresponds to regular memory), "knl_hbm", and "ppc_hbm". The "hbm" options are high-bandwidth memory on the KNL and Power PC chips, respectively. If Global Arrays has not been compiled using SICM, the memory device option is ignored and a conventional global array is created. </p>
<hr/>
<h3 id="SET_MEMORY_LIMIT">SET MEMORY LIMIT</h3>
<i>Limits the internal memory used by the GA runtime</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_memory_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>limit</td><td>the amount of memory in bytes per process</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 Sets the amount of memory to be used (in bytes) per process </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#INITIALIZE_LTD">INITIALIZE LTD</a>
<hr/>
<h3 id="SET_PGROUP">SET PGROUP</h3>
<i>Specifies what the processor group will be for a GA handle</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_pgroup</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">p_handle</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>p_handle</td><td>processor group handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to set the processor configuration assigned to a global array handle that was obtained using the GA_Create_handle function. It can be used to create mirrored arrays by using the mirrored array processor configuration in this function call. It can also be used to create an array on a processor group by using a processor group handle in this call. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ALLOCATE">ALLOCATE</a>
<hr/>
<h3 id="SET_PROPERTY">SET PROPERTY</h3>
<i>Assign a property to a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_property</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">property</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>character*(*)</td><td>character string representing the property</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function allows users to assign properties to an array if there is advanced knowledge that an array will be used in a certain way. The two properties currently supported are "read_only" and "read_cache". These can both be set after the global array is allocated. </p>
<p>
 The read_only property is similar to creating a mirrored array in that the global array is replicated across an SMP node. This speeds up access to array data since all transfers can occur by shared memory copies on the same node. However, memory utilization increases since the global array is replicated across nodes even though it is distributed within a node. Setting the read_only property results in significant overhead since data for the array must be copied and redistributed. However, if the array is only used for read operations after initialization, this setting may be usefull in applications. </p>
<p>
 The read_cache property is useful when an application may be repeatedly accessing the same data. The read_cache property stores the recent blocks of data obtained via "get" operations. If a subsequent "get" requests the same data or a subset of the data, the data is obtained from the stored request instead of requesting it over the network. This can speed up performance if there are many duplicate requests for data. The total number of requests that are cached is limited and requests are stored in the cache on a first in, first out basis. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#UNSET_PROPERTY">UNSET PROPERTY</a>
<hr/>
<h3 id="SET_RESTRICTED">SET RESTRICTED</h3>
<i>Specifies a GA handle will be allocated on a subset of processors</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_restricted</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">nproc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>list(nproc)</td><td>list of processor IDs that contain data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nproc</td><td>number of processors that contain data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function restricts data in the global array g_a to only the nproc processors listed in the array list. The value of nproc must be less than or equal to the number of available processors. If this call is used in conjunction with GA_Set_irreg_distr, then the decomposition in the GA_Set_irreg_distr call must be done assuming that the number of processors is nproc. The data that ordinarily would be mapped to process 0 is mapped to the process in list[0], the data that would be mapped to process 1 will be mapped to list[1], etc. This can be used to remap the data distribution to different processors, even if nproc equals the number of available processors. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SET_RESTRICTED_RANGE">SET RESTRICTED RANGE</a>
<hr/>
<h3 id="SET_RESTRICTED_RANGE">SET RESTRICTED RANGE</h3>
<i>Specifies a GA handle will be created on a subset (as a range) of processors</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_restricted_range</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo_proc</span><span class="p">,</span> <span class="n">hi_proc</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo_proc</td><td>range of processors (inclusive) that contain data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi_proc</td><td>range of processors (inclusive) that contain data</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function restricts data in the global array to the range of processors beginning with lo_proc and ending with hi_proc. Both lo_proc and hi_proc must be less than or equal to the total number of processors minus one (e.g., in the range [0,N-1], where N is the total number of processors) and lo_proc must be less than or equal to hi_proc. If lo_proc = 0 and hi_proc = N-1 then this call has no effect on the data distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SET_RESTRICTED">SET RESTRICTED</a>
<hr/>
<h3 id="SET_TILED_IRREG_PROC_GRID">SET TILED IRREG PROC GRID</h3>
<i>This function specifies that the GA will use a distribution of irregularly sized blocks that will be assigned to processors using SCALAPACK-type block cyclic data distribution with individual blocks being contiguous in memory</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_tiled_irreg_proc_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">mapc</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">proc_grid</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>mapc(s)</td><td>starting index of each block. s is equal to the sum of indices in nblocks array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>nblocks(ndim)</td><td>array containing the number of blocks in each dimension</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>proc_grid(ndim)</td><td>processor grid dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This subroutine is a combination of the function that set an irregular distribution and the function for creating a tiled block-cyclic distribution. Like the conventional tiled block-cylic distribution, individual blocks are contiguous in memory. Unlike the conventional tiled distribution, individual blocks can vary in size. The mapc array consists of the starting index of each block along each dimension and the number of blocks along each axis is stored in the nblocks array. The number of entries in mapc equals the sum of the entries in nblocks. The proc_grid array describes how blocks are distributed over processors using a block-cylic distribution. The product of the entries in proc_grid is equal to the number of processors in the group that the global array is created on. </p>
<p>
 Note that the values in the nblocks arrays should be greater than or equal to the corresponding values in the proc_grid array. </p>
<h4>See Also:</h4>
<a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>, <a target="api" href="#SET_IRREG_DISTR">SET IRREG DISTR</a>
<hr/>
<h3 id="SET_TILED_PROC_GRID">SET TILED PROC GRID</h3>
<i>This function specifies that the GA will use a regular SCALAPACK-type block cyclic data distribution but individual blocks will be contiguous in memory</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_set_tiled_proc_grid</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">block_dims</span><span class="p">,</span> <span class="n">proc_grid</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>block_dims(ndim)</td><td>array of block dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>proc_grid(ndim)</td><td>array of processor grid dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This subroutine is used to create a global array with a SCALAPACK-type block cyclic data distribution but with individual blocks that are contiguous in memory. This layout may be preferable for algorithms that are moving single blocks of data since the corresponding messages will involve contiguous data transfers instead of strided calls. This may result in performance gains for communication bound programs. Otherwise, the data layout is similar to that created by the block-cyclic processor grid function. </p>
<p>
 The user specifies the dimensions of the processor grid in the array proc_grid. The product of the processor grid dimensions must equal the number of total number of processors and the number of dimensions in the processor grid must be the same as the number of dimensions in the global array. The data blocks are mapped onto the processor grid in a cyclic manner along each of the processor grid axes. The dimensions of individual blocks are located in the block_dims array. </p>
<h4>See Also:</h4>
<a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>
<hr/>
<h3 id="SHIFT_DIAGONAL">SHIFT DIAGONAL</h3>
<i>Adds specified constant to diagonal elements of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_shift_diagonal</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double/complex/integer/float</td><td>c</td><td>shift value</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Adds this constant to the diagonal elements of the matrix. </p>
<hr/>
<h3 id="SOLVE">SOLVE</h3>
<i>Solves a system of linear equations</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_solve</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>coefficient matrix</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>rhs/solution matrix</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Solves a system of linear equations </p>
<pre>
            A * X = B
</pre>
<p>
</p>
<p>
 It first will call the Cholesky factorization routine and, if sucessfully, will solve the system with the Cholesky solver. If Cholesky will be not be able to factorize A, then it will call the LU factorization routine and will solve the system with forward/backward substitution. On exit B will contain the solution X. </p>
<p>
 It returns </p>
<pre>
         = 0 : Cholesky factoriztion was succesful
         > 0 : the leading minor of this order
               is not positive definite, Cholesky factorization
               could not be completed and LU factoriztion was used
</pre>
<p>
</p>
<p>
 </p>
<hr/>
<h3 id="SPD_INVERT">SPD INVERT</h3>
<i>Inverts a symmetric positive definite matrix</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_spd_invert</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>matrix</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 It computes the inverse of a double precision using the Cholesky factorization of a NxN double precision symmetric positive definite matrix A stored in the global array represented by g_a. On successful exit, A will contain the inverse. </p>
<p>
 It returns </p>
<pre>
         = 0 : successful exit
         > 0 : the leading minor of this order is not positive
               definite and the factorization could not be completed
         < 0 : it returns the index i of the (i,i)
               element of the factor L/U that is zero and
               the inverse could not be computed
</pre>
<p>
</p>
<p>
 </p>
<hr/>
<h3 id="STEP_MAX">STEP MAX</h3>
<i>Computes a global array's step max</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_step_max</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_b</td><td>array handles</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td></td><td>step</td><td>double precision/integer; the maximum step</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Calculates the largest multiple of a vector g_b that can be added to this vector g_a while keeping each element of this vector non-negative. </p>
<hr/>
<h3 id="STEP_MAX_PATCH">STEP MAX PATCH</h3>
<i>Computes a global array patch's step max</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_step_max_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="n">bhi</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a,g_b</td><td>array handles where g_b is step direction</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo,ahi,blo,bhi</td><td>patch coordinates of g_a and g_b</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>double precision</td><td>step</td><td>the maximum step</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Calculates the largest multiple of a vector g_b that can be added to this vector g_a while keeping each element of this vector non-negative. </p>
<hr/>
<h3 id="STRIDED_ACC">STRIDED ACC</h3>
<i>Accumulates strided data into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_strided_acc</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>skip(ndim)</td><td>array of strides for each dimension</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data comes from</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>alpha</td><td>scale argument for accumulate</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 This operation is the same as NGA_Acc, except that the values corresponding to dimension n in buf are accumulated to every skip[n] values of the global array g_a. </p>
<p>
 Combines data from buffer with data in the global array patch. </p>
<p>
 The buffer array is assumed to be have the same number of dimensions as the global array. </p>
<p>
 global array section (lo[],hi[]) += alpha * buffer </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ACC">ACC</a>
<hr/>
<h3 id="STRIDED_GET">STRIDED GET</h3>
<i>Get strided data from a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_strided_get</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>skip(ndim)</td><td>array of strides for each dimension</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data comes from</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for buffer array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 This operation is the same as NGA_Get, except that the values corresponding to dimension n in buf correspond to every skip[n] values of the global array g_a. </p>
<p>
 The local array is assumed to be have the same number of dimensions as the global array. Any detected inconsitencies/errors in the input arguments are fatal. </p>
<p>
 Returns: The local array buffer. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#GET">GET</a>
<hr/>
<h3 id="STRIDED_PUT">STRIDED PUT</h3>
<i>Puts strided data into a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_strided_put</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions of the global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo(ndim)</td><td>array of starting indices for global</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>hi(ndim)</td><td>array of ending indices for global array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>skip(ndim)</td><td>array of strides for each dimension</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>type</td><td>buf</td><td>local buffer array where the data comes from</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>ld(ndim-1)</td><td>array specifying leading dimensions for array section</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Strided version of put.  This operation is the same as NGA_Put, except that the values corresponding to dimension n in buf are copied to every skip[n] values of the global array g_a. </p>
<p>
 Copies data from local array buffer to the global array section. </p>
<p>
 The local array is assumed to be have the same number of dimensions as the global array. </p>
<p>
 Any detected inconsitencies/errors in input arguments are fatal. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#PUT">PUT</a>
<hr/>
<h3 id="SUMMARIZE">SUMMARIZE</h3>
<i>Prints summary information on a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_summarize</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>logical</td><td>verbose</td><td>If true print distribution info</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Local operation.</p>
<p>
Prints info about allocated arrays. </p>
<hr/>
<h3 id="SYMMETRIZE">SYMMETRIZE</h3>
<i>Symmetrizes a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_symmetrize</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span>/<span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Symmetrizes matrix A represented with handle g_a: A:= .5 * (A+A'). </p>
<hr/>
<h3 id="SYNC">SYNC</h3>
<i>Synchronizes all processes in the default processor group</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_sync</span><span class="p">()</span>
</pre></div>
<p>Collective on the default processor group.</p>
<p>
</p>
<p>
 Synchronize processes (a barrier) and ensure that all GA operations completed. </p>
<p>
 </p>
<hr/>
<h3 id="TERMINATE">TERMINATE</h3>
<i>Terminates GA</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_terminate</span><span class="p">()</span>
</pre></div>
<p>Collective on the world processor group.</p>
<p>
</p>
<p>
 Delete all active arrays and destroy internal data structures. </p>
<p>
 </p>
<hr/>
<h3 id="TOTAL_BLOCKS">TOTAL BLOCKS</h3>
<i>Returns number of blocks allocated when using block-cyclic distribution</i>
<div class="highlight"><pre><span></span><span class="kt">integer </span><span class="k">function </span><span class="n">ga_total_blocks</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td></td><td>total number of blocks in the block-cyclic distribution</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Local operation.</p>
<p>
</p>
<p>
 This function returns the total number of blocks contained in a global array with a block-cyclic data distribution. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#SET_BLOCK_CYCLIC">SET BLOCK CYCLIC</a>, <a target="api" href="#SET_BLOCK_CYCLIC_PROC_GRID">SET BLOCK CYCLIC PROC GRID</a>
<hr/>
<h3 id="TRANSPOSE">TRANSPOSE</h3>
<i>Transposes a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_transpose</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>remains unchanged</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_b</td><td>solution matrix</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Transposes a matrix: B = A', where A and B are represented by handles g_a and g_b. </p>
<hr/>
<h3 id="UNLOCK">UNLOCK</h3>
<i>Unlocks a mutex</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>mutex</td><td>mutex id</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>One-sided (non-collective).</p>
<p>
</p>
<p>
 Unlocks a mutex object identified by the mutex number. It is a fatal error for a process to attempt to unlock a mutex which has not been locked by this process. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#CREATE_MUTEXES">CREATE MUTEXES</a>, <a target="api" href="#DESTROY_MUTEXES">DESTROY MUTEXES</a>, <a target="api" href="#LOCK">LOCK</a>
<hr/>
<h3 id="UNPACK">UNPACK</h3>
<i>Expands values from a source vector based on a corresponding integer mask</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_unpack</span><span class="p">(</span><span class="n">g_src</span><span class="p">,</span> <span class="n">g_dest</span><span class="p">,</span> <span class="n">g_mask</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">icount</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_src</td><td>handle for source array</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>g_dest</td><td>handle for destination array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
<tr><td>integer</td><td>g_mask</td><td>handle for integer array representing a bit mask</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>lo,hi</td><td>low and high values of range on which operation is performed</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>icount</td><td>number of values in uncompressed array</td><td><span style="color: rgb(102, 0, 0);">output</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
The unpack subroutine is designed to expand the values in the source vector g_src into a larger destination array g_dest based on the values in an integer mask array g_mask. The values lo and hi denote the range of elements that should be compressed and icount is a variable that on output lists the number of values placed in the uncompressed array. This operation is the complement of the GA_Pack operation. An example is shown below. </p>
<pre>
GA_Unpack(g_src, g_dest, g_mask, 1, n, &icount);

g_src:    1  7  9 12 15 16
g_mask:   1  0  0  0  0  0  1  0  1  0  0  1  0  0  1  1  0
g_dest:   1  0  0  0  0  0  7  0  9  0  0 12  0  0 15 16  0
icount:   6

</pre>
<p>
</p>
<p>
 The current implementation requires that the distribution of the g_mask array matches the distribution of the g_dest array. </p>
<hr/>
<h3 id="UNSET_PROPERTY">UNSET PROPERTY</h3>
<i>Assign a property to a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_unset_property</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>global array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
This function clears properties from the global array. </p>
<h4>See Also:</h4>
<a target="api" href="#SET_PROPERTY">SET PROPERTY</a>
<hr/>
<h3 id="UPDATE_GHOST_DIR">UPDATE GHOST DIR</h3>
<i>Updates ghost cells along a specific direction</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">nga_update_ghost_dir</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span><span class="k">dimension</span><span class="p">,</span><span class="n">idir</span><span class="p">,</span><span class="n">cflag</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>dimension</td><td>array dimension that is to be updated</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>idir</td><td>direction of update (+/-1)</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>logical</td><td>cflag</td><td>flag to include corners in update</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This function can be used to update the ghost cells along individual directions. It is designed for algorithms that can overlap updates with computation. The variable dimension indicates which coordinate direction is to be updated (e.g. dimension = 1 would correspond to the y axis in a two or three dimensional system), the variable idir can take the values +/-1 and indicates whether the side that is to be updated lies in the positive or negative direction, and cflag indicates whether or not the corners on the side being updated are to be included in the update. The following calls would be equivalent to a call to GA_Update_ghosts for a 2-dimensional system: </p>
<p>
 </p>
<pre>
     status = NGA_Update_ghost_dir(g_a,0,-1,1);
     status = NGA_Update_ghost_dir(g_a,0,1,1);
     status = NGA_Update_ghost_dir(g_a,1,-1,0);
     status = NGA_Update_ghost_dir(g_a,1,1,0);
</pre>
<p>
</p>
<p>
 The variable cflag is set equal to 1 (or non-zero) in the first two calls so that the corner ghost cells are update, it is set equal to 0 in the second two calls to avoid redundant updates of the corners. Note that updating the ghosts cells using several independent calls to the nga_update_ghost_dir functions is generally not as efficient as using GA_Update_ghosts unless the individual calls can be effectively overlapped with computation. </p>
<p>
 </p>
<hr/>
<h3 id="UPDATE_GHOSTS">UPDATE GHOSTS</h3>
<i>Updates ghost cells</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_update_ghosts</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 This call updates the ghost cell regions on each processor with the corresponding neighbor data from other processors. The operation assumes that all data is wrapped around using periodic boundary data so that ghost cell data that goes beyound an array boundary is wrapped around to the other end of the array. The GA_Update_ghosts call contains two GA_Sync calls before and after the actual update operation. For some applications these calls may be unecessary, if so they can be removed using the GA_Mask_sync subroutine. </p>
<p>
 </p>
<hr/>
<h3 id="USES_MA">USES MA</h3>
<i>Checks whether GA uses MA</i>
<div class="highlight"><pre><span></span><span class="kt">logical </span><span class="k">function </span><span class="n">ga_uses_ma</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
</p>
<p>
 Returns "1" if memory in global arrays comes from the Memory Allocator (MA). "0" means that memory comes from another source, for example System V shared memory is used. </p>
<p>
 TODO </p>
<p>
 </p>
<hr/>
<h3 id="WTIME">WTIME</h3>
<i>Returns time in seconds since an arbitrary time in the past</i>
<div class="highlight"><pre><span></span><span class="kt">double precision </span><span class="k">function </span><span class="n">ga_wtime</span><span class="p">()</span>
</pre></div>
<p>Local operation.</p>
<p>
This function returns a wall (or elapsed) time on the calling processor. Returns time in seconds representing elapsed wall-clock time since an arbitrary time in the past. Example: </p>
<pre>
double starttime, endtime;
starttime = GA_Wtime();
.... code snippet to be timed ....
endtime   = GA_Wtime();
printf("Time taken = %lf seconds\n", endtime-starttime);
</pre>
<p>
This function is only available in release 4.1 or greater. </p>
<hr/>
<h3 id="ZERO">ZERO</h3>
<i>Zeros a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_zero</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Sets value of all elements in the array to zero. </p>
<p>
 </p>
<hr/>
<h3 id="ZERO_DIAGONAL">ZERO DIAGONAL</h3>
<i>Zeros the diagonal elements of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">ga_zero_diagonal</span><span class="p">(</span><span class="n">g_a</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td>array handle</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
Sets the diagonal elements of this matrix g_a with zeros. </p>
<hr/>
<h3 id="ZERO_PATCH">ZERO PATCH</h3>
<i>Zeros a patch of a global array</i>
<div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">nga_zero_patch</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">)</span>
</pre></div>
<table>
<tr><th>Type</th><th>Name</th><th>Description</th><th>Intent</th></tr>
<tr><td>integer</td><td>g_a</td><td></td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>ndim</td><td>number of dimensions</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
<tr><td>integer</td><td>alo(ndim), ahi(ndim)</td><td>g_a patch coordinates</td><td><span style="color: rgb(0, 102, 0);">input</span></td>
</table>
<p>Collective on the processor group inferred from the arguments.</p>
<p>
</p>
<p>
 Set all the elements in the patch to zero. </p>
<p>
 </p>
<h4>See Also:</h4>
<a target="api" href="#ZERO">ZERO</a>

    </body>
</html>
